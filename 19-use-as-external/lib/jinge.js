/**
 * jinge mvvm framework
 * @version: 1.0.6
 * @copyright: 2019 Yuhang Ge <abeyuhang@gmail.com>
 * @license: MIT
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.jinge = {}));
}(this, (function (exports) { 'use strict';

  function typeOf(v) {
    return typeof v;
  }

  function isObject(v) {
    return v !== null && typeOf(v) === 'object';
  }

  function isString(v) {
    return typeOf(v) === 'string';
  }

  function isNumber(v) {
    return typeOf(v) === 'number' && !Number.isNaN(v) && Number.isFinite(v);
  }

  function isUndefined(v) {
    return typeOf(v) === 'undefined';
  }

  function isArray(v) {
    return Array.isArray(v);
  }

  function isBoolean(v) {
    return typeof v === 'boolean' || instanceOf(v, Boolean);
  }

  function isFunction(v) {
    return typeOf(v) === 'function';
  }

  function instanceOf(v, Clazz) {
    return v instanceof Clazz;
  }

  function isDOMNode(ele) {
    return instanceOf(ele, Node);
  }

  function isPromise(obj) {
    return isObject(obj) && isFunction(obj.then);
  }

  function arrayIndexOf(array, item) {
    return array.indexOf(item);
  }

  function arrayRemove(array, item) {
    const idx = arrayIndexOf(array, item);
    if (idx < 0) return false;
    array.splice(idx, 1);
    return true;
  }

  function arrayPushIfNotExist(array, item) {
    const idx = arrayIndexOf(array, item);
    if (idx >= 0) return;
    array.push(item);
  }

  function arrayFind(array, predicate) {
    if (array.find) {
      return array.find(predicate);
    } else {
      const i = arrayFindIndex(array, predicate);
      return i >= 0 ? array[i] : null;
    }
  }

  function arrayFindIndex(array, predicate) {
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) return i;
    }
    return -1;
  }

  function arrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i]) return false;
    }
    return true;
  }

  const STR_DEFAULT = 'default';
  const STR_JINGE = 'jinge';
  const STR_EMPTY = 'empty';
  const STR_LENGTH = 'length';

  const BEFORE_DESTROY_EVENT_NAME = 'jinge.before-destroy';
  const AFTER_RENDER_EVENT_NAME = 'jinge.after-render';

  /* eslint camelcase: "off" */
  /**
   * Constants below are prepared for code auto generated by compiler.
   */
  const HTML_ATTR_checked = 'checked';
  const HTML_ATTR_disabled = 'disabled';
  const HTML_ATTR_selected = 'selected';
  const HTML_ATTR_readOnly = 'readOnly';
  const HTML_ATTR_autofocus = 'autofocus';
  const HTML_ATTR_autocomplete = 'autocomplete';
  const HTML_ATTR_required = 'required';
  const HTML_ATTR_controls = 'controls';
  const HTML_ATTR_autoplay = 'autoplay';
  const HTML_ATTR_draggable = 'draggable';
  const HTML_ATTR_multiple = 'multiple';
  const HTML_ATTR_muted = 'muted';
  const HTML_ATTR_value = 'value';

  function Symbol$1(description) {
    return window.Symbol(description);
  }

  function assertFail(msg) {
    msg && console.error(msg);
    throw new Error('assert failed!');
  }

  function startsWith(str, search, position = 0) {
    return str.startsWith(search, position);
  }

  function endsWith(str, search, endPosition) {
    return str.endsWith(search, endPosition);
  }

  function defineProperty(...args) {
    return Object.defineProperty(...args);
  }

  function assignObject(target, ...srcs) {
    return Object.assign(target, ...srcs);
  }

  function obj2class(obj, prepend) {
    const classes = Object.keys(obj).filter(k => obj[k]).join(' ').trim();
    return prepend ? `${prepend}${classes ? ' ' + classes : ''}` : classes;
  }

  function obj2style(obj) {
    return Object.keys(obj).map(k => {
      return `${k}: ${obj[k]}`;
    }).join(';').trim();
  }

  function defineProperties(...args) {
    return Object.defineProperties(...args);
  }

  /**
   * @param {Object} obj
   * @param {Function} enumFn
   */
  function getOwnPropertyNames(obj, enumFn) {
    const ns = Object.getOwnPropertyNames(obj);
    if (enumFn) ns.forEach(enumFn);
    return ns;
  }

  /**
   * @param {Object} obj
   * @param {Function} enumFn
   */
  function getOwnPropertySymbols(obj, enumFn) {
    const ss = Object.getOwnPropertySymbols(obj);
    if (enumFn) ss.forEach(enumFn);
    return ss;
  }

  function isPropertyEnumerable(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  }

  function createEmptyObject(o) {
    return Object.create(o || null);
  }

  function uid() {
    return Date.now().toString(32) + Math.floor(Math.random() * 0xffff).toString(32);
  }

  function mapObject(obj, fn) {
    const newObj = {};
    for (const k in obj) {
      newObj[k] = fn(obj[k], k);
    }
    return newObj;
  }

  function getOrCreateProperty(obj, property, fn) {
    let v = obj[property];
    if (!v) {
      v = obj[property] = fn();
    }
    return v;
  }

  function getOrCreateValueOfMap(map, key, fn) {
    let v = map.get(key);
    if (!v) {
      v = fn();
      map.set(key, v);
    }
    return v;
  }

  function getOrCreateMapProperty(obj, property) {
    return getOrCreateProperty(obj, property, () => new Map());
  }

  function getOrCreateArrayValueOfMap(map, key) {
    return getOrCreateValueOfMap(map, key, () => []);
  }

  function getOrCreateArrayProperty(obj, property) {
    return getOrCreateProperty(obj, property, () => []);
  }

  /**
   * setImmediate polyfill only for modern browsers
   * Copied from https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js
   * Simplified by Yuhang-Ge<abeyuhang@gmail.com>
   */

  let nextHandle = 1; // Spec says greater than zero
  let tasksByHandle;
  let currentlyRunningATask = false;
  let registerImmediate;

  function setImmediateFallback(callback) {
    if (!isFunction(callback) || arguments.length > 1) assertFail();
    tasksByHandle.set(nextHandle, callback);
    registerImmediate(nextHandle);
    // console.log('siiii', callback);
    return nextHandle++;
  }

  function clearImmediateFallback(handle) {
    tasksByHandle.delete(handle);
  }

  function runIfPresent(handle) {
    // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // 'too much recursion' error.
      return setTimeout(runIfPresent, 0, handle);
    }
    const callback = tasksByHandle.get(handle);
    // console.log('stttt', handle, callback);

    if (!callback) return;
    currentlyRunningATask = true;
    try {
      callback();
    } finally {
      clearImmediateFallback(handle);
      currentlyRunningATask = false;
    }
  }

  if (isUndefined(window.setImmediate)) {
    tasksByHandle = new Map();
    const messagePrefix = 'setImmediate$' + uid() + '$';
    window.addEventListener('message', event => {
      if (event.source === window &&
        isString(event.data) &&
        startsWith(event.data, messagePrefix)) {
        runIfPresent(Number(event.data.slice(messagePrefix.length)));
      }
    }, false);

    registerImmediate = function(handle) {
      window.postMessage(messagePrefix + handle, '*');
    };
  }

  const setImmediate = window.setImmediate || setImmediateFallback;
  const clearImmediate = window.clearImmediate || clearImmediateFallback;

  function getParent($ele) {
    return $ele.parentNode;
  }

  function setText($element, text) {
    if (isArray(text)) {
      text = JSON.stringify(text);
    }
    $element.textContent = text;
  }

  function setAttribute($ele, attrName, attrValue) {
    if (!attrName) return;
    if (isObject(attrName)) {
      for (const attrN in attrName) {
        setAttribute($ele, attrN, attrName[attrN]);
      }
      return;
    }
    if (isUndefined(attrValue) || attrValue === null) {
      removeAttribute($ele, attrName);
    } else {
      $ele.setAttribute(attrName, attrValue);
    }
  }

  function removeAttribute($ele, attrName) {
    if (!attrName) return;
    if (isObject(attrName)) {
      for (const attrN in attrName) {
        removeAttribute($ele, attrN);
      }
      return;
    }
    return $ele.removeAttribute(attrName);
  }

  function setInputValue($inputOrTextarea, value) {
    $inputOrTextarea.value = value;
  }

  function _createEl($el, attrs, children) {
    if (attrs) {
      for (const an in attrs) {
        if (an && !isUndefined(attrs[an])) {
          setAttribute($el, an, attrs[an]);
        }
      }
    }
    children.forEach(child => appendChild($el, child));
    return $el;
  }

  function createElement(tag, attrs, ...children) {
    return _createEl(
      document.createElement(tag),
      attrs, children
    );
  }

  function createElementWithoutAttrs(tag, ...children) {
    return createElement(tag, null, ...children);
  }

  function createSVGElement(tag, attrs, ...children) {
    return _createEl(
      document.createElementNS('http://www.w3.org/2000/svg', tag),
      attrs, children
    );
  }

  function createSVGElementWithoutAttrs(tag, ...children) {
    return createSVGElement(tag, null, ...children);
  }

  function createFragment(children) {
    const $f = document.createDocumentFragment();
    if (children) children.forEach(c => appendChild($f, c));
    return $f;
  }

  function createTextNode(text = '') {
    return document.createTextNode(text);
  }

  function createElementWithChild(tag, attrs, child) {
    const $e = createElement(tag, attrs);
    appendChild($e, child);
    return $e;
  }

  function createComment(data) {
    return document.createComment(data);
  }

  function prepareNewNode(newNode) {
    if (!isArray(newNode)) return newNode;
    if (newNode.length === 0) return null;
    else if (newNode.length === 1) return newNode[0];
    else {
      return createFragment(newNode);
    }
  }

  function replaceChild($parent, newNode, oldNode) {
    if (!(newNode = prepareNewNode(newNode))) {
      return;
    }
    $parent.replaceChild(newNode, oldNode);
  }

  function insertBefore($parent, newNode, referenceNode) {
    if (!(newNode = prepareNewNode(newNode))) {
      return;
    }
    $parent.insertBefore(newNode, referenceNode);
  }

  function insertAfter($parent, newNode, referenceNode) {
    if (!(newNode = prepareNewNode(newNode))) {
      return;
    }
    const rn = referenceNode.nextSibling;
    if (!rn) {
      appendChild($parent, newNode);
    } else {
      insertBefore($parent, newNode, rn);
    }
  }

  function removeChild($parent, $child) {
    $parent.removeChild($child);
  }

  function appendChild($parent, ...children) {
    children.forEach(ch => {
      if (isArray(ch)) {
        return ch.forEach(cc => appendChild($parent, cc));
      }
      if (isString(ch)) {
        ch = createTextNode(ch);
      }
      $parent.appendChild(ch);
    });
  }

  function hasClass($ele, className) {
    return $ele.classList.contains(className);
  }

  function toggleClass($ele, ...args) {
    return $ele.classList.toggle(...args);
  }
  function addClass($ele, className) {
    return toggleClass($ele, className, true);
  }

  function removeClass($ele, className) {
    return toggleClass($ele, className, false);
  }

  function replaceClass($ele, oldClass, newClass) {
    return $ele.classList.replace(oldClass, newClass);
  }

  function addEvent($element, eventName, handler, capture = false) {
    $element.addEventListener(eventName, handler, capture);
  }

  function removeEvent($element, eventName, handler) {
    $element.removeEventListener(eventName, handler);
  }

  /**
   * Add event to DOM element, similar as addEventListener,
   * but return deregister function which will call removeEventListener.
   *
   * @param {HtmlElement} $element
   * @param {String} eventName
   * @param {Function} handler
   * @param {Boolean|Object} capture
   * @returns {Function} deregister function which will removeEventListener
   */
  function registerEvent($element, eventName, handler, capture) {
    addEvent($element, eventName, handler, capture);
    return function deregister() {
      removeEvent($element, eventName, handler);
    };
  }

  function getComputedStyle$1(el, pseudoElt) {
    return window.getComputedStyle(el, pseudoElt);
  }

  function getCSPropertyValue(cst, prop) {
    return cst.getPropertyValue(prop);
  }

  const VM_ATTRS = Symbol$1('vm_injected_attrs');
  const VM_DEBUG_NAME = Symbol$1('name');
  const VM_PROXY = Symbol$1('wrapper_proxy_of_host');
  const VM_ON = Symbol$1('fn_add_listener');
  const VM_OFF = Symbol$1('fn_remove_listener');
  const VM_NOTIFY = Symbol$1('fn_notify_listener');
  const VM_NOTIFIABLE = Symbol$1('notifiable');
  const VM_HOST = Symbol$1('host');
  const VM_RELATED_LISTENERS = Symbol$1('vm_related_listeners');

  const PARENTS = Symbol$1('parents');
  const LISTENERS_STAR = Symbol$1('*');
  const LISTENERS_DBSTAR = Symbol$1('**');
  const LISTENERS = Symbol$1('listeners');
  const LISTENERS_ID = Symbol$1('listenrs_id');
  const LISTENERS_PARENT = Symbol$1('vm_listeners_parent');
  const LISTENERS_HANDLERS = Symbol$1('vm_listeners_handlers');

  const VM_ADD_PARENT = Symbol$1('fn_add_parent');
  const VM_REMOVE_PARENT = Symbol$1('fn_remove_parent');
  const VM_SHIFT_PARENT = Symbol$1('fn_shift_parent');
  const VM_DESTROY = Symbol$1('fn_destroy');

  function isInnerObj(v) {
    const clazz = v.constructor;
    return clazz === RegExp || clazz === Date || clazz === Boolean;
  }
  function isViewModel(obj) {
    return isObject(obj) && !isInnerObj(obj) && (VM_ATTRS in obj);
  }

  function isPublicProp(v) {
    return isString(v) && v.charCodeAt(0) !== 95;
  }

  class Node$1 {
    constructor(parentNode, propertyName) {
      this[LISTENERS_PARENT] = parentNode;
      this[LISTENERS_ID] = propertyName;
      this[LISTENERS] = null;
      this[LISTENERS_HANDLERS] = null;
    }
  }

  function getPropN(v) {
    if (v === LISTENERS_DBSTAR || v === LISTENERS_STAR || isString(v)) {
      return v;
    }
    if (v === null) {
      return 'null';
    }
    if (isUndefined(v)) {
      return 'undefined';
    }
    return v.toString();
  }

  function loopCreateNode(vm, props, level = 0) {
    const propertyName = getPropN(props[level]);
    if (!propertyName) {
      return null;
    }
    const listeners = getOrCreateMapProperty(vm, LISTENERS);
    let node = listeners.get(propertyName);
    if (!node) {
      node = new Node$1(vm, propertyName);
      listeners.set(propertyName, node);
    }
    if (props.length - 1 === level) {
      return node;
    } else {
      return loopCreateNode(node, props, level + 1);
    }
  }

  function loopGetNode(vm, props, level = 0) {
    const propertyName = getPropN(props[level]);
    if (!propertyName) {
      return null;
    }
    const listeners = vm[LISTENERS];
    const node = listeners.get(propertyName);
    if (!node) {
      return null;
    }
    if (props.length - 1 === level) {
      return node;
    } else {
      return loopGetNode(node, props, level + 1);
    }
  }

  function delNode(node) {
    if ((node[LISTENERS_HANDLERS] && node[LISTENERS_HANDLERS].length > 0) ||
      (node[LISTENERS] && node[LISTENERS].size > 0)
    ) {
      return;
    }
    /**
     * if one node don't have any listener or child, delete it.
     */
    const parent = node[LISTENERS_PARENT];
    const id = node[LISTENERS_ID];
    node[LISTENERS_PARENT] = null; // unlink parent.
    parent[LISTENERS].delete(id);
    return parent;
  }

  function loopClearNode(node, isRoot = true) {
    const listeners = node[LISTENERS];
    if (listeners) {
      // loop clear all child nodes
      listeners.forEach(sn => loopClearNode(sn, false));
      listeners.clear();
      node[LISTENERS] = null;
    }
    if (isRoot) {
      return;
    }
    // destroy all handlers
    const handlers = node[LISTENERS_HANDLERS];
    if (handlers) {
      // clear handler waiting to execute
      handlers.forEach(_handleCancel);
      handlers.length = 0;
      node[LISTENERS_HANDLERS] = null;
    }
    // unlink parent
    node[LISTENERS_PARENT] = null;
  }

  const _handleTasks = new Map();
  function _handleCancel(handler) {
    const t = _handleTasks.get(handler);
    if (t) {
      clearImmediate(t.i);
      _handleTasks.delete(handler);
    }
  }
  function _handleOnce(node, handler, propPath) {
    if (_handleTasks.has(handler)) {
      return;
    }
    const imm = setImmediate(() => {
      const arg = _handleTasks.get(handler);
      try {
        handler(arg.p);
      } finally {
        _handleTasks.delete(handler);
      }
    });
    _handleTasks.set(handler, {
      i: imm,
      p: propPath
    });
  }

  function loopHandle(propPath, node) {
    const handlers = node[LISTENERS_HANDLERS];
    handlers && handlers.forEach(handler => {
      _handleOnce(node, handler, propPath);
      // imms ? _handleOnce(node, handler, propPath) : handler(propPath);
    });
    const listeners = node[LISTENERS];
    listeners && listeners.forEach(c => {
      loopHandle(propPath, c);
    });
  }

  function loopNotify(vm, props, level = 0) {
    const listeners = vm[LISTENERS];
    if (!listeners) {
      return;
    }
    const propertyName = getPropN(props[level]);
    if (!propertyName) {
      return;
    }
    let node = listeners.get(propertyName);
    if (node) {
      if (props.length - 1 === level) {
        // loopHandle(props, node, config[CFG_VM_DEBUG] ? null : imms);
        loopHandle(props, node);
      } else {
        loopNotify(node, props, level + 1);
      }
    }
    node = listeners.get(LISTENERS_STAR);
    if (node) {
      if (props.length - 1 === level) {
        loopHandle(props, node);
      } else {
        loopNotify(node, props, level + 1);
      }
    }
    node = listeners.get(LISTENERS_DBSTAR);
    if (node) {
      loopHandle(props, node);
    }
  }

  function getProps(prop) {
    return isString(prop) ? (
      prop.indexOf('.') > 0 ? prop.split('.') : [prop]
    ) : prop;
  }

  class ViewModelAttrs {
    constructor(host) {
      this[VM_HOST] = host;
      this[VM_NOTIFIABLE] = true;
      this[VM_PROXY] = null;
      this[PARENTS] = null;
      this[LISTENERS] = null;
    }

    [VM_ADD_PARENT](parent, prop) {
      const pArr = getOrCreateArrayProperty(this, PARENTS);
      pArr.push([parent, prop]);
    }

    [VM_REMOVE_PARENT](parent, prop) {
      const pArr = this[PARENTS];
      if (!pArr) return;
      const idx = pArr.findIndex(ps => ps[0] === parent && ps[1] === prop);
      if (idx >= 0) pArr.splice(idx, 1);
    }

    [VM_SHIFT_PARENT](parent, prop, delta) {
      const pArr = this[PARENTS];
      if (!pArr) return;
      const ps = pArr.find(ps => ps[0] === parent && ps[1] === prop);
      if (ps) {
        ps[1] += delta;
      }
    }

    [VM_ON](prop, handler, relatedComponent) {
      const node = loopCreateNode(this, getProps(prop));
      if (!node) {
        return;
      }
      arrayPushIfNotExist(
        getOrCreateArrayProperty(node, LISTENERS_HANDLERS),
        handler
      );
      const host = this[VM_HOST];
      if (!relatedComponent || !(VM_RELATED_LISTENERS in relatedComponent)) {
        return;
      }
      // unwrap component out of wrapper proxy
      relatedComponent = relatedComponent[VM_ATTRS][VM_HOST];
      if (host === relatedComponent) {
        return;
      }
      vmRelatedOn(relatedComponent, host, prop, handler);
    }

    [VM_OFF](prop, handler, relatedComponent) {
      const node = loopGetNode(this, getProps(prop));
      if (!node) {
        return;
      }

      const hs = node[LISTENERS_HANDLERS];
      if (!handler) { // remove all if second parameter is not provided
        hs.forEach(_handleCancel);
        hs.length = 0;
      } else {
        _handleCancel(handler);
        arrayRemove(hs, handler);
      }

      delNode(node);

      const host = this[VM_HOST];
      if (!relatedComponent || !(VM_RELATED_LISTENERS in relatedComponent)) {
        return;
      }
      // unwrap component out of wrapper proxy
      relatedComponent = relatedComponent[VM_ATTRS][VM_HOST];
      if (host === relatedComponent) {
        return;
      }
      vmRelatedOff(relatedComponent, host, prop, handler);
    }

    [VM_NOTIFY](prop) {
      if (!this[VM_NOTIFIABLE]) {
        return;
      }
      const props = getProps(prop);
      if (this[LISTENERS]) {
        loopNotify(this, props);
      }
      const pArr = this[PARENTS];
      pArr && pArr.forEach(ps => {
        const vmAttrs = ps[0][VM_ATTRS];
        if (!vmAttrs) {
          console.error('dev-warn-unexpected: parent of ViewModelAttrs has been destroied but not unlink.');
          return;
        }
        vmAttrs[VM_NOTIFY](
          [ps[1]].concat(props)
        );
      });
    }

    [VM_DESTROY](unlinkHostProperties = true) {
      // mark as non-notifiable
      this[VM_NOTIFIABLE] = false;
      // clear assignment parents
      const pArr = this[PARENTS];
      pArr && (pArr.length = 0);
      this[PARENTS] = null;
      // clear listeners
      loopClearNode(this);
      // unlink host object wrapper proxy
      this[VM_PROXY] = null;

      const host = this[VM_HOST];

      // destroy related listeners
      if (VM_RELATED_LISTENERS in host) {
        vmRelatedClear(host[VM_RELATED_LISTENERS]);
        host[VM_RELATED_LISTENERS] = null;
      }
      // unlink vm host
      this[VM_HOST] = null;
      /*
       * by default, we will reset VM_HOST object's all public properties to null
       *   to remove VM_HOST object from old property value's VM_PARENTS
       *
       * 默认情况下（即 === true），会将 VM_HOST 对象的所有（不以 '_' 打头的）公共属性重置为 null，这个赋值会触发 ./proxy.js 中的逻辑，
       *   将该对象从属性原来的值的 VM_PARENTS 中移除，从而达到解除 ViewModel 之间的关联，回收资源和防止潜在 bug 的目的。
       *
       * 当 VM 对象是某个类的实例时，由于类可以通过 setter 函数定义公共属性，而这一类的公共属性不能
       *   通过 getOwnPropertyNames 来遍历。因此这种情况，需要主动传递 unlinkHostProperties = false
       *   来禁用默认的重置属性逻辑，然后自己处理相关的重置逻辑。比如 Component 组件。
       */
      unlinkHostProperties && getOwnPropertyNames(host, prop => {
        if (prop.charCodeAt(0) === 95) {
          return;
        }
        const v = host[prop];
        if (!isObject(v)) {
          return;
        }
        const a = v[VM_ATTRS];
        a && a[VM_REMOVE_PARENT](host, prop);
        host[prop] = null;
      });
    }
  }

  function vmRelatedOn(relatedComponent, hostViewModel, prop, handler) {
    const rvl = getOrCreateMapProperty(relatedComponent, VM_RELATED_LISTENERS);
    let hook = rvl.get(hostViewModel);
    if (!hook) {
      hook = [];
      rvl.set(hostViewModel, hook);
    }
    hook.push([prop, handler]);
  }

  function vmRelatedOff(relatedComponent, hostViewModel, prop, handler) {
    const rvl = relatedComponent[VM_RELATED_LISTENERS];
    if (!rvl) return;
    const hook = rvl.get(hostViewModel);
    if (!hook) return;
    const isPropArray = isArray(prop);
    const i = hook.findIndex(it => {
      return handler === it[1] &&
        (isPropArray
          ? arrayEqual(prop, it[0])
          : prop === it[0]
        );
    });
    if (i >= 0) {
      hook.splice(i, 1);
    }
  }

  function vmRelatedClear(relatedListeners) {
    if (!relatedListeners) return;
    relatedListeners.forEach((arr, component) => {
      arr.forEach(hook => {
        component[VM_ATTRS][VM_OFF](hook[0], hook[1]);
      });
      arr.length = 0;
    });
    relatedListeners.clear();
  }

  class RelatedListenersStore {
    constructor() {
      /**
       * VM_ON/VM_OFF 绑定属性监听接受三个参数，其中第三个参数为关联组件。
       *   当关联组件被销毁时，可以同时销毁保存在其 VM_RELATED_LISTENERS 中的父亲 ViewModel 的
       *   属性监听函数（参看 ../core/component.js 里 VM_RELATED_LISTENERS 的注释）。
       *
       * 在多语言国际化方案中，当 attrs 渲染函数代码被提取到独立的多语言资源文件后，除了关联组件被销毁时需要销毁父 ViewModel 的属性监听，
       *   当 locale 发生变化时，这些监听函数也要销毁。为了实现这个目标，采用了一个取巧的思路，传递一个模拟的关联组件，
       *   即 RelatedListenersStore 来存储 VM_RELATED_LISTENERS。
       *
       * 以下的 VM_RELATED_LISTENERS 和 VM_ATTRS 的定义就是为了实现该模拟，使得
       *   VM_ON/VM_OFF 函数可以正常执行关联组件的逻辑。
       */
      this[VM_RELATED_LISTENERS] = null;
      this[VM_ATTRS] = {
        [VM_HOST]: this
      };
    }

    // destroy
    d() {
      vmRelatedClear(this[VM_RELATED_LISTENERS]);
      this[VM_RELATED_LISTENERS] = null;
    }
  }

  function vmWatch(vm, prop, handler) {
    const vmAttrs = vm[VM_ATTRS];
    if (!vmAttrs) {
      throw new Error('vmWatch require ViewModel object');
    }
    let dbStarIdx = -1;
    const props = getProps(prop).map((p, i) => {
      if (p === '**') {
        dbStarIdx = i;
        return LISTENERS_DBSTAR;
      }
      return p === '*' ? LISTENERS_STAR : p;
    });
    if (dbStarIdx >= 0 && dbStarIdx !== props.length - 1) {
      /**
       * 'a.b.**' is good.
       * 'a.b.**.c' is bad.
       */
      throw new Error('wizard "**" must be last element in path.');
    }
    vmAttrs[VM_ON](props, handler);
  }

  function vmUnwatch(vm, prop, handler) {
    const vmAttrs = vm[VM_ATTRS];
    if (!vmAttrs[VM_NOTIFIABLE]) {
      return;
    }
    if (!prop) {
      loopClearNode(vmAttrs);
    } else {
      vmAttrs[VM_OFF](prop, handler);
    }
  }

  const VM_SETTER_FN_MAP = Symbol$1('vm_setter_fn_map');

  /**
   * check if property named "prop" is setter of instance "obj",
   * if it's setter, return setter function, otherwise return null.
   * @param {Object} obj
   * @param {String} prop
   *
   * 检测名称为 "prop" 的属性是否是 setter，如果是，返回该 setter 函数，
   * 否则，返回 null。
   * 由于 obj 可能是有继承关系的类的实例，因此需要向上检测继承的类的 prototype。
   */
  function getSetterFnIfPropIsSetter(obj, prop) {
    const map = getOrCreateMapProperty(obj, VM_SETTER_FN_MAP);
    if (!map.has(prop)) {
      let clazz = obj.constructor;
      let desc = Object.getOwnPropertyDescriptor(clazz.prototype, prop);
      let fn;
      if (desc) {
        fn = isFunction(desc.set) ? desc.set : null;
        map.set(prop, fn);
        return fn;
      }
      // lookup to check parent classes
      clazz = Object.getPrototypeOf(clazz);
      while (clazz && clazz.prototype) {
        desc = Object.getOwnPropertyDescriptor(clazz.prototype, prop);
        if (desc) {
          fn = isFunction(desc.set) ? desc.set : null;
          map.set(prop, fn);
          return fn;
        }
        clazz = Object.getPrototypeOf(clazz);
      }
      map.set(prop, null);
      return null;
    } else {
      return map.get(prop);
    }
  }

  function notifyPropChanged(vm, prop) {
    vm[VM_ATTRS][VM_NOTIFY](prop);
  }

  function __propSetHandler(target, prop, value, setFn) {
    if (!isPublicProp(prop)) {
      target[prop] = value;
      return true;
    }
    const oldVal = target[prop];
    if (oldVal === value && !isUndefined(value)) {
      return true;
    }
    const newValIsVM = isObject(value) && !isInnerObj(value);
    if (newValIsVM && !(VM_ATTRS in value)) {
      throw new Error(`public property "${prop}" of ViewModel must also be ViewModel`);
    }
    // console.log(`'${prop}' changed from ${store[prop]} to ${value}`);
    if (isObject(oldVal)) {
      const a = oldVal[VM_ATTRS];
      a && a[VM_REMOVE_PARENT](target, prop);
    }
    setFn(target, prop, value);
    if (newValIsVM) {
      value[VM_ATTRS][VM_ADD_PARENT](target, prop);
    }
    notifyPropChanged(target, prop);
    return true;
  }

  function __objectPropSetFn(target, prop, value) {
    target[prop] = value;
  }

  function __componentPropSetFn(target, prop, value) {
    /**
     * we must ensure `this` in setter function to be `Proxy`
     *
     * 首先判断当前赋值的变量名，是否对应了一个 setter 函数，
     * 如果是 setter 函数，则应该显式地调用，
     *   并将 `this` 设置为该 target 的包装 Proxy，
     *   这样才能保正 setter 函数中其它赋值语句能触发 notify。
     * 如果不是 setter 函数，则简单地使用 target\[prop\] 赋值即可。
     */
    const setterFn = getSetterFnIfPropIsSetter(target, prop);
    if (setterFn) {
      setterFn.call(target[VM_ATTRS][VM_PROXY], value);
    } else {
      target[prop] = value;
    }
  }

  function objectPropSetHandler(target, prop, value) {
    if (!target[VM_ATTRS]) {
      // ViewModel has been destroied.
      return true;
    }
    return __propSetHandler(target, prop, value, __objectPropSetFn);
  }

  function componentPropSetHandler(target, prop, value) {
    if (!target[VM_ATTRS]) {
      console.warn(`call setter "${prop.toString()}" after destroied, resources such as setInterval maybe not released before destroy. component:`, target);
      return true;
    }
    return __propSetHandler(target, prop, value, __componentPropSetFn);
  }

  function arrayPropSetHandler(target, prop, value) {
    if (prop === STR_LENGTH) {
      return arrayLengthSetHandler(target, value);
    }
    return objectPropSetHandler(target, prop, value);
  }

  function arrayNotifyItems(target, idxStart, idxEnd) {
    let i = idxStart;
    if (idxStart > idxEnd) {
      i = idxEnd;
      idxEnd = idxStart;
    }
    for (; i < idxEnd; i++) {
      // console.log('npc', i);
      notifyPropChanged(target, i);
    }
  }

  function arrayLengthSetHandler(target, value) {
    if (!isNumber(value)) throw new Error('bad argument. array length must be validate number.');
    const oldLen = target.length;
    if (oldLen > value) {
      for (let i = value; i < oldLen; i++) {
        const v = target[i];
        isViewModel(v) && v[VM_ATTRS][VM_REMOVE_PARENT](target, i);
      }
    }
    target.length = value;
    // console.log('set .length from', oldLen, 'to', value);
    if (oldLen !== value) {
      notifyPropChanged(target, STR_LENGTH);
      arrayNotifyItems(target, oldLen, value);
    }
    return true;
  }

  const ObjectProxyHandler = {
    set: objectPropSetHandler
  };

  const ComponentProxyHandler = {
    set: componentPropSetHandler
  };

  const PromiseProxyHandler = {
    get(target, prop) {
      if (prop === 'then' || prop === 'catch') {
        const v = target[prop];
        return function(...args) {
          return v.call(target, ...args);
        };
      } else {
        return target[prop];
      }
    },
    set: objectPropSetHandler
  };

  function _arrayFill(target, v) {
    target.forEach((it, i) => {
      if (it === v && !isUndefined(it)) {
        return;
      }
      if (isViewModel(it)) {
        it[VM_ATTRS][VM_REMOVE_PARENT](target, i);
      }
      target[i] = v;
      if (isViewModel(it)) {
        it[VM_ATTRS][VM_ADD_PARENT](target, i);
      }
      notifyPropChanged(target, i);
    });
    return target[VM_ATTRS][VM_PROXY];
  }

  function _arrayReverseSort(target, fn, arg) {
    target.forEach((it, i) => {
      if (isViewModel(it)) {
        it[VM_ATTRS][VM_ADD_PARENT](target, i);
      }
    });
    target[fn](arg);
    target.forEach((it, i) => {
      if (isViewModel(it)) {
        it[VM_ATTRS][VM_REMOVE_PARENT](parent, i);
      }
    });
    arrayNotifyItems(target, 0, target.length);
    // return wrapper proxy to ensure `arr.reverse() === arr`
    return target[VM_ATTRS][VM_PROXY];
  }

  function _arrayWrapSub(arr, wrapEachItem = false) {
    const rtn = wrapProxy(arr, true);
    // handleVMDebug(arr);
    arr.forEach((it, i) => {
      if (isViewModel(it)) {
        it[VM_ATTRS][VM_ADD_PARENT](arr, i);
      } else if (wrapEachItem) {
        arr[i] = loopWrapVM(it);
      }
    });
    return rtn;
  }

  function _arrayShiftOrUnshiftProp(arr, delta) {
    arr.forEach((el, i) => {
      if (!isViewModel(el)) return;
      el[VM_ATTRS][VM_SHIFT_PARENT](arr, i, delta);
    });
  }

  function _argAssert(arg, fn) {
    if (isObject(arg)) {
      if (!(VM_ATTRS in arg)) {
        throw new Error(`argument passed to Array.${fn} must be ViewModel if the array is ViewModel`);
      } else {
        return true;
      }
    } else {
      return false;
    }
  }

  const ArrayFns = {
    splice(target, idx, delCount, ...args) {
      if (idx < 0) idx = 0;
      args.forEach((arg, i) => {
        if (_argAssert(arg, 'splice')) {
          arg[VM_ATTRS][VM_ADD_PARENT](target, idx + i);
        }
      });
      for (let i = 0; i < delCount; i++) {
        if (idx + i >= target.length) break;
        const el = target[idx + i];
        if (isViewModel(el)) {
          el[VM_ATTRS][VM_REMOVE_PARENT](target, idx + i);
        }
      }
      const delta = args.length - delCount;
      if (delta !== 0) {
        for (let i = idx + delCount; i < target.length; i++) {
          const el = target[i];
          if (!isViewModel(el)) continue;
          el[VM_ATTRS][VM_SHIFT_PARENT](target, i, delta);
        }
      }
      const rtn = _arrayWrapSub(target.splice(idx, delCount, ...args));
      if (delta !== 0) {
        notifyPropChanged(target, STR_LENGTH);
        for (let i = idx; i < target.length; i++) {
          notifyPropChanged(target, i);
        }
      }
      return rtn;
    },
    shift(target) {
      if (target.length === 0) return target.shift();
      _arrayShiftOrUnshiftProp(target, -1);
      const el = target.shift();
      if (isViewModel(el)) {
        el[VM_ATTRS][VM_REMOVE_PARENT](target, -1);
      }
      notifyPropChanged(target, STR_LENGTH);
      for (let i = 0; i < target.length + 1; i++) {
        notifyPropChanged(target, i);
      }
      return el;
    },
    unshift(target, ...args) {
      if (args.length === 0) return target.unshift();
      args.forEach((arg, i) => {
        if (_argAssert(arg, 'unshift')) {
          arg[VM_ATTRS][VM_ADD_PARENT](target, i);
        }
      });
      _arrayShiftOrUnshiftProp(target, args.length);
      const rtn = target.unshift(...args);
      notifyPropChanged(target, STR_LENGTH);
      for (let i = 0; i < target.length; i++) {
        notifyPropChanged(target, i);
      }
      return rtn;
    },
    pop(target) {
      if (target.length === 0) {
        return target.pop();
      }
      const el = target.pop();
      if (isViewModel(el)) {
        el[VM_ATTRS][VM_REMOVE_PARENT](target, target.length);
      }
      notifyPropChanged(target, STR_LENGTH);
      notifyPropChanged(target, target.length);
      return el;
    },
    push(target, ...args) {
      if (args.length === 0) return target.push();
      args.forEach((arg, i) => {
        if (_argAssert(arg, 'push')) {
          arg[VM_ATTRS][VM_ADD_PARENT](target, target.length + i);
        }
      });
      const rtn = target.push(...args);
      notifyPropChanged(target, STR_LENGTH);
      for (let i = target.length - 1 - args.length; i < target.length; i++) {
        notifyPropChanged(target, i);
      }
      return rtn;
    },
    fill(target, v) {
      _argAssert(v, 'fill');
      return _arrayFill(target, v);
    },
    reverse(target) {
      return _arrayReverseSort(target, 'reverse');
    },
    sort(target, fn) {
      return _arrayReverseSort(target, 'sort', fn);
    },
    concat(target, arr) {
      _argAssert(arr, 'concat');
      return _arrayWrapSub(target.concat(arr));
    },
    filter(target, fn) {
      return _arrayWrapSub(target.filter(fn));
    },
    slice(target, si, ei) {
      return _arrayWrapSub(target.slice(si, ei));
    },
    map(target, fn) {
      return _arrayWrapSub(target.map(fn), true);
    }
  };

  const ArrayProxyHandler = {
    get(target, prop) {
      if (prop in ArrayFns) {
        const fn = ArrayFns[prop];
        return function(...args) {
          return fn(target, ...args);
        };
      } else {
        return target[prop];
      }
    },
    set: arrayPropSetHandler
  };

  function wrapProp(vm, prop) {
    const v = vm[prop];
    if (!isObject(v) || isInnerObj(v)) {
      return;
    }
    if (VM_ATTRS in v) {
      v[VM_ATTRS][VM_ADD_PARENT](vm, prop);
      return;
    }
    vm[prop] = loopWrapVM(v);
    v[VM_ATTRS][VM_ADD_PARENT](vm, prop);
  }

  function wrapProxy(vm, isArr) {
    const vmAttrs = new ViewModelAttrs(vm);
    vm[VM_ATTRS] = vmAttrs;
    const p = new Proxy(vm, isArr ? ArrayProxyHandler : (
      isPromise(vm) ? PromiseProxyHandler : ObjectProxyHandler
    ));
    vmAttrs[VM_PROXY] = p;
    return p;
  }

  function loopWrapVM(plainObjectOrArray) {
    if (isObject(plainObjectOrArray)) {
      // directly return if alreay is ViewModel or inner object(Date/RegExp/Boolean).
      if (isInnerObj(plainObjectOrArray) || (VM_ATTRS in plainObjectOrArray)) {
        return plainObjectOrArray;
      }

      if (isArray(plainObjectOrArray)) {
        for (let i = 0; i < plainObjectOrArray.length; i++) {
          wrapProp(plainObjectOrArray, i);
        }
        return wrapProxy(plainObjectOrArray, true);
      } else {
        for (const k in plainObjectOrArray) {
          if (isPublicProp(k)) {
            wrapProp(plainObjectOrArray, k);
          }
        }
        return wrapProxy(plainObjectOrArray, false);
      }
    } else {
      return plainObjectOrArray;
    }
  }

  function wrapViewModel(plainObjectOrArray) {
    const vm = loopWrapVM(plainObjectOrArray);
    // if (vm !== plainObjectOrArray) {
    //   handleVMDebug(plainObjectOrArray);
    // }
    return vm;
  }

  // alias for convenient
  const VM = wrapViewModel;

  // function handleVMDebug(vm) {
  //   if (!config[CFG_VM_DEBUG]) {
  //     return;
  //   }
  //   let _di = window._VM_DEBUG;
  //   if (!_di) {
  //     _di = window._VM_DEBUG = {
  //       id: 0, vms: []
  //     };
  //   }
  //   vm[VM_DEBUG_ID] = _di.id++;
  //   // if (isComponent(vm) && !(VM_DEBUG_NAME in vm)) {
  //   //   vm[VM_DEBUG_NAME] = `<${vm.constructor.name}>`;
  //   // }
  //   _di.vms.push(vm);
  // }

  function wrapComponent(component) {
    if (component[VM_ATTRS]) {
      throw new Error('alreay wraped.');
    }
    // handleVMDebug(component);
    const vmAttrs = new ViewModelAttrs(component);
    // 初始化时 Component 默认的 VM_NOTIFIABLE 为 false，
    // 待 RENDER 结束后才修改为 true，用于避免无谓的消息通知。
    vmAttrs[VM_NOTIFIABLE] = false;
    component[VM_ATTRS] = vmAttrs;
    const p = new Proxy(component, ComponentProxyHandler);
    vmAttrs[VM_PROXY] = p;
    return p;
  }

  function wrapAttrs(attrsObj) {
    if (!isObject(attrsObj)) {
      assertFail();
    }
    for (const k in attrsObj) {
      if (isPublicProp(k)) {
        const v = attrsObj[k];
        if (isObject(v) && !isInnerObj(v) && !(VM_ATTRS in v)) {
          throw new Error(`value passed to attribute "${k}" must be ViewModel.`);
        }
      }
    }
    const attrs = wrapProxy(attrsObj, false);
    // 初始化时 Component 默认的 VM_NOTIFIABLE 为 false，
    // 待 RENDER 结束后才修改为 true，用于避免无谓的消息通知。
    attrs[VM_ATTRS][VM_NOTIFIABLE] = false;
    return attrs;
  }

  const LISTENERS$1 = Symbol$1('listeners');

  function notifyHelper(listenersMap, notifyKey, ...notifyArgs) {
    if (!listenersMap) return;
    const listeners = listenersMap.get(notifyKey);
    if (!listeners) return;
    listeners.forEach(handler => handler(...notifyArgs));
  }

  function onHelper(listenersMap, notifyKey, listener) {
    const listeners = getOrCreateArrayValueOfMap(listenersMap, notifyKey);
    if (listeners.indexOf(listener) < 0) {
      listeners.push(listener);
    }
  }

  function offHelper(listenersMap, notifyKey, listener) {
    if (!listenersMap) return;
    if (!notifyKey) {
      listenersMap.forEach(ls => {
        ls.length = 0;
      });
      listenersMap.clear();
      return;
    }
    const listeners = listenersMap.get(notifyKey);
    if (!listeners) return;
    if (!listener) {
      listeners.length = 0; // clear all if listener is not provided
      return;
    }
    const idx = listeners.indexOf(listener);
    if (idx < 0) return;
    listeners.splice(idx, 1);
  }

  function clearHelper(listenersMap, notifyKey) {
    if (!listenersMap) return;
    if (!notifyKey) {
      listenersMap.clear();
    } else {
      listenersMap.delete(notifyKey);
    }
  }

  function onceHelper(listenersMap, notifyKey, listener) {
    function onceListener(...args) {
      listener(...args);
      offHelper(listenersMap, notifyKey, onceListener);
    }
    onHelper(listenersMap, notifyKey, onceListener);
  }

  const NOTIFY = Symbol$1('notify');
  const ON = Symbol$1('on');
  const OFF = Symbol$1('off');
  const CLEAR = Symbol$1('clear');

  class Messenger {
    /**
     * Listeners compiled from template.
     * @param {Object} templateListeners
     */
    constructor(templateListeners) {
      this[LISTENERS$1] = null;
      if (templateListeners) {
        for (const eventName in templateListeners) {
          this[ON](eventName, ...templateListeners[eventName]);
        }
      }
    }

    [NOTIFY](eventName, ...args) {
      notifyHelper(this[LISTENERS$1], eventName, ...args);
    }

    [ON](eventName, eventListener, opts) {
      const listeners = getOrCreateMapProperty(this, LISTENERS$1);
      if (opts) {
        eventListener.tag = opts;
      }
      if (opts && opts.once) {
        onceHelper(listeners, eventName, eventListener);
      } else {
        onHelper(listeners, eventName, eventListener);
      }
    }

    [OFF](eventName, eventListener) {
      offHelper(this[LISTENERS$1], eventName, eventListener);
    }

    [CLEAR](eventName) {
      clearHelper(this[LISTENERS$1], eventName);
    }
  }

  /**
   * pass all listeners on srcMessenger to dstMessenger
   * @param {Messenger} srcMessenger
   * @param {Messenger} dstMessenger
   */
  function passListeners(srcMessenger, dstMessenger) {
    if (!(LISTENERS$1 in srcMessenger) || !(LISTENERS$1 in dstMessenger)) {
      // src or dst is not instance of Messenger
      return;
    }
    const srcLis = srcMessenger[LISTENERS$1];
    if (!srcLis) return;
    srcLis.forEach((lis, key) => {
      const dstLis = getOrCreateMapProperty(dstMessenger, LISTENERS$1);
      lis.forEach(listener => {
        const tag = listener.tag;
        if (tag && tag.once) {
          onceHelper(dstLis, key, listener);
        } else {
          onHelper(dstLis, key, listener);
        }
      });
    });
  }

  const CSTYLE_PID = Symbol$1('cstyle_pids');
  const CSTYLE_ADD = Symbol$1('add');
  const CSTYLE_DEL = Symbol$1('del');
  const CSTYLE_ATTACH = Symbol$1('attach');

  function addParentStyleId(component, inheritIds, styleId) {
    if (!inheritIds && !styleId) return;
    let ids = component[CSTYLE_PID];
    if (!ids) {
      ids = component[CSTYLE_PID] = createEmptyObject();
    }
    if (inheritIds) {
      assignObject(ids, inheritIds);
    }
    if (styleId) {
      ids[styleId] = '';
    }
  }

  function isHideCssExists() {
    const $e = createElement('span', {
      style: 'position:absolute;left:-10000px;',
      class: 'jg-hide'
    });
    appendChild(document.body, $e);
    return getCSPropertyValue(getComputedStyle($e), 'display') === 'none';
  }

  class ComponentStyleManager {
    constructor() {
      this.m = new Map();
      /**
       * State
       * 0: not attached
       * 1: attached
       */
      this.s = 0;
    }

    _c(sty) {
      if (this.s === 0) return;
      const $style = createElement('style', {
        type: 'text/css',
        id: sty.dom
      });
      appendChild(document.head, $style);
      if ($style.styleSheet) {
        $style.styleSheet.cssText = sty.css;
      } else {
        $style.textContent = sty.css;
      }
    }

    [CSTYLE_ADD](sty) {
      if (!sty) return;
      const styleMap = this.m;
      let info = styleMap.get(sty.id);
      if (info) {
        info.refs++;
        return;
      }
      info = {
        id: sty.id,
        css: sty.css,
        dom: `__${sty.id}__`,
        refs: 1
      };
      styleMap.set(sty.id, info);
      this._c(info);
    }

    [CSTYLE_ATTACH]() {
      if (this.s !== 0) return;
      this.s = 1;
      if (!isHideCssExists()) {
        this._c({
          dom: `__jgsty_${uid()}__`,
          css: '.jg-hide{display:none!important}.jg-hide.jg-hide-enter,.jg-hide.jg-hide-leave{display:block!important}'
        });
      }
      this.m.forEach(info => this._c(info));
    }

    [CSTYLE_DEL](sty) {
      if (!sty) return;
      const info = this.m.get(sty.id);
      if (!info) return;
      info.refs--;
      if (info.refs > 0) {
        return;
      }
      this.m.delete(info.id);
      if (this.s === 0) return;
      document.head.removeChild(
        document.getElementById(info.dom)
      );
    }
  }

  // singleton
  const manager = new ComponentStyleManager();

  const I18N_GET_RENDER = Symbol$1('fn_get_render');
  const I18N_GET_TEXT = Symbol$1('fn_get_text');
  const I18N_GET_ATTR = Symbol$1('fn_get_attr');
  const I18N_LOCALE_CHANGE = Symbol$1('locale_change');
  const I18N_SWITCH_LOCALE = Symbol$1('switch_locale');
  const I18N_RENDER_DEPS = Symbol$1('register_render_dependent_functions');
  const I18N_CURRENT_LOCALE = Symbol$1('current_locale');

  const LAST_FETCHING_KEY = Symbol$1('last_fetching_key');
  const CURRENT_DATA = Symbol$1('current_data');
  const CACHE = Symbol$1('cache');

  function compile(text) {
    // eslint-disable-next-line no-new-func
    return new Function('__ctx', `return \`${text.replace(/\$\{\s*([\w\d._$]+)\s*\}/g, (m, n) => {
    return '${ __ctx.' + n + ' }';
  })}\`;`);
  }

  function defaultFetchFn(locale) {
    return window.fetch('dist/locale.' + locale + '.js').then(res => res.text());
  }

  class I18nService extends Messenger {
    constructor(attrs) {
      super(attrs);
      this[I18N_RENDER_DEPS] = null;
      this[CURRENT_DATA] = null;
      this[CACHE] = new Map();
      this[LAST_FETCHING_KEY] = null;

      this.r(window.JINGE_I18N_DATA);
    }

    get locale() {
      return this[CURRENT_DATA].locale;
    }

    /**
     * Register locale data, will be called in locale resource script.
     * Usually you don't need call this method manully.
     */
    r(data) {
      if (!data || this[CACHE].has(data.locale)) {
        return;
      }
      this[CACHE].set(data.locale, data);
      if (!this[CURRENT_DATA]) {
        this[CURRENT_DATA] = data;
      }
    }

    /**
     * switch to another locale/language
     * @param {String} locale locale to swtiched
     * @param {Function} fetchFn a function to fetch locale resource script.
     */
    switch(locale, fetchFn = defaultFetchFn) {
      if (this[CURRENT_DATA].locale === locale) {
        return;
      }
      const data = this[CACHE].get(locale);
      if (!data) {
        if (fetchFn) {
          const key = uid();
          this[LAST_FETCHING_KEY] = key;
          fetchFn(locale).then(code => {
            // eslint-disable-next-line no-new-func
            (new Function('jinge', code))({
              i18n: this
            });
            if (this[LAST_FETCHING_KEY] !== key || this[CURRENT_DATA].locale === locale) {
              /*
               * ignore if callback has been expired.
               * 使用闭包的技巧来检测当前回调是否已经过期，
               * 即，是否已经有新的 fetchFn 函数的调用。
               */
              return;
            }
            const data = this[CACHE].get(locale);
            this[CURRENT_DATA] = data;
            this[NOTIFY](I18N_LOCALE_CHANGE, this.locale);
          });
        } else {
          throw new Error(`i18n data of "${locale}" is not found. `);
        }
      } else {
        this[CURRENT_DATA] = data;
        this[NOTIFY](I18N_LOCALE_CHANGE, this.locale);
      }
    }

    [I18N_GET_TEXT](key, params) {
      const dict = this[CURRENT_DATA].dictionary;
      if (!(key in dict)) {
        return 'i18n_missing';
      }
      let text = dict[key];
      if (isString(text)) {
        // text.startsWith("«") means reference to another key
        if (text.charCodeAt(0) === 171) {
          text = dict[text.substring(1)];
        } else {
          text = compile(text);
        }
        dict[key] = text;
      }
      return text(params);
    }

    [I18N_GET_RENDER](key) {
      return getRenderOrAttr(this[CURRENT_DATA], this[I18N_RENDER_DEPS], 'render', key);
    }

    [I18N_GET_ATTR](key) {
      return getRenderOrAttr(this[CURRENT_DATA], this[I18N_RENDER_DEPS], 'attribute', key);
    }

    /**
     * Bind listener to LOCALE_CHANGE event,
     * return a function auto remove this listener
     * @param {Function} handler a listener bind to LOCALE_CHANGE event
     * @param {Boolean} immediate call listener immediately, default is false.
     * @returns {Function} a function auto remove listener
     */
    watch(listener, immediate) {
      this[ON](I18N_LOCALE_CHANGE, listener);
      if (immediate) listener(this.locale);
      return function unwatcher() {
        this[OFF](I18N_LOCALE_CHANGE, listener);
      };
    }
  }

  function getRenderOrAttr(data, depFns, type, key) {
    let renderOrAttr = data[type];
    if (isFunction(renderOrAttr)) {
      data[type] = renderOrAttr = (depFns ? renderOrAttr(...depFns[type]) : {});
    }
    if (!(key in renderOrAttr)) {
      throw new Error(`missing i18n ${type} for key: ${key}`);
    }
    let fn = renderOrAttr[key];
    if (isString(fn)) {
      // if fn is string, it's a reference to another key.
      renderOrAttr[key] = fn = renderOrAttr[fn];
    }
    return fn;
  }

  /* Singleton */
  const i18n = new I18nService();

  /**
   * Compiler helper function, the first parameter will be convert to i18n dictionary key,
   * and the whole function will be transform to `i18nService[GET_TEXT](key, params)`
   *
   * But after i18n locale resource script had been written, compiler won't transform it,
   * the function will work as text parse util.
   *
   * @param {String|Object} text
   * @param {Object} params
   */
  function _t(text, params) {
    return params ? compile(text)(params) : text;
  }

  const NOTIFY_TRANSITION = Symbol$1('notify_transition');
  const TEMPLATE_RENDER = Symbol$1('template_render');
  const RENDER = Symbol$1('render');
  const RENDER_TO_DOM = Symbol$1('render_to_dom');
  const ARG_COMPONENTS = Symbol$1('arg_components');
  const PASSED_ATTRS = Symbol$1('passed_attrs');
  const CLONE = Symbol$1('clone');
  const DESTROY = Symbol$1('destroy');
  const CONTEXT = Symbol$1('context');
  const CONTEXT_STATE = Symbol$1('context_state');
  const ROOT_NODES = Symbol$1('root_nodes');
  const NON_ROOT_COMPONENT_NODES = Symbol$1('non_root_components');
  const REF_NODES = Symbol$1('ref_nodes');
  const SET_REF_NODE = Symbol$1('setChild');
  const REF_BELONGS = Symbol$1('ref_belongs');
  const RELATED_DOM_REFS = Symbol$1('related_dom_refs');
  const GET_STATE_NAME = Symbol$1('get_state_name');
  const AFTER_RENDER = Symbol$1('afterRender');
  const HANDLE_AFTER_RENDER = Symbol$1('handleAfterRender');
  const HANDLE_BEFORE_DESTROY = Symbol$1('handleBeforeDestroy');
  const GET_FIRST_DOM = Symbol$1('getFirstHtmlDOM');
  const GET_LAST_DOM = Symbol$1('getLastHtmlDOM');
  const GET_TRANSITION_DOM = Symbol$1('getTransitionDOM');
  const BEFORE_DESTROY = Symbol$1('beforeDestroy');
  const GET_CONTEXT = Symbol$1('getContext');
  const SET_CONTEXT = Symbol$1('setContext');
  const GET_REF = Symbol$1('getRef');
  const UPDATE = Symbol$1('update');
  const UPDATE_IF_NEED = Symbol$1('update_if_need');
  const UPDATE_NEXT_MAP = Symbol$1('update_next_tick_map');
  const STATE = Symbol$1('state');
  const STATE_INITIALIZE = 0;
  const STATE_RENDERED = 1;
  const STATE_WILLDESTROY = 2;
  const STATE_DESTROIED = 4;
  const STATE_NAMES = [
    'initialize', 'rendered', 'willdestroy', 'destroied'
  ];

  const DOM_ON = Symbol$1('add_dom_listener');
  const DOM_PASS_LISTENERS = Symbol$1('pass_all_listeners_to_dom');

  const I18N_WATCH = Symbol$1('i18n_watch');
  const DOM_LISTENER_DEREGISTERS = Symbol$1('dom_listener_deregisters');
  const I18N_LISTENER_DEREGISTERS = Symbol$1('i18n_listener_deregisters');

  function copyContext(context) {
    if (!context) return null;
    return assignObject(createEmptyObject(), context);
  }

  class Component extends Messenger {
    /**
     * compiler will auto transform the `template` getter's return value from String to Render Function.
     */
    static get template() {
      return null;
    }

    static get style() {
      return null;
    }

    /**
     * @param {Attributes} attrs Attributes passed from parent Component
     */
    constructor(attrs) {
      if (!isObject(attrs) || !(VM_ATTRS in attrs)) {
        throw new Error('First argument passed to Component constructor must be ViewModel with Messenger interface. See https://[todo]');
      }
      super(attrs[LISTENERS$1]);

      this[PASSED_ATTRS] = attrs;

      this[VM_ATTRS] = null;
      this[VM_SETTER_FN_MAP] = null;

      this[UPDATE_NEXT_MAP] = null;
      this[CSTYLE_PID] = null;
      this[CONTEXT] = attrs[CONTEXT];
      this[CONTEXT_STATE] = 0;
      this[ARG_COMPONENTS] = attrs[ARG_COMPONENTS];
      this[STATE] = STATE_INITIALIZE;
      /**
       * ROOT_NODES means root children of this component,
       *   include html-nodes and component-nodes.
       * We use this infomation to remove DOM after this component is destroied.
       * We do not maintain the whole parent-child view-tree but only root children,
       * because when we remove the root children, whole view-tree will be
       * removed, so we do not need waste memory to maintain whole view-tree.
       */
      this[ROOT_NODES] = [];
      /**
       * NON_ROOT_COMPONENT_NODES means nearest non-root component-nodes in the view-tree.
       * Node in view-tree have two types, html-node and component-node.
       *   html-node include html dom node and html text node,
       *   component-node is an instance of a Component.
       * For example, we have rendered a view-tree:
       *             RootApp(Component)
       *             /     |          \
       *         h1(Html)  h2(Html)  A(Component)
       *            |                 |
       *        C(Component)     D(Component)
       *
       * The nearest non-root component-nodes of RootApp include C,
       *   but not include A(as it's root) or D(as it's not nearest).
       *
       * By the way, the ROOT_NODES of view-tree above is [h1, h2, A]
       */
      this[NON_ROOT_COMPONENT_NODES] = [];
      /**
       * REF_NODES contains all children with ref: attribute.
       * REF_BELONGS contains all parent components which has this component as ref.
       *
       * 使用 ref: 标记的元素（Component 或 html node），会保存在 REF_NODES 中，
       *   之后通过 GET_REF 函数可以获取到元素实例。
       * 当标记的元素属于 <if> 或 <for> 等组件的 slot 时，这些元素可能被动态产生或销毁。
       *   需要在元素产生或销毁时，相应地把它从它所属于的 REF_NODES 中添加或删除。
       * 为了实现这个目的，对于 Component 元素，在将它添加到目标父组件的 REF_NODES 中的同时，
       *   会将目标父组件反向记录到该元素的 REF_BELONGS 中，从而实现当该元素被销毁时，
       *   可以将自己从它所属于的 REF_NODES 中删除；
       * 对于 html node 元素，我们会将其目标父组件记录到该元素的渲染关联组件的 RELATED_DOM_REFS。
       *   比如说，如果该 html 元素是 <if> 组件的 slot ，那它的渲染关联组件就是 <if> 内部的 Slot 组件，
       *   当 <if> 的条件发生变化时，实际上会销毁这个 Slot 组件。由于前面提到的 html 元素
       *   的 ref: 信息记录到了该 Slot 组件的 RELATED_DOM_REFS 里，因此就能反向地将
       *   这个 html 元素从它所属于的 REF_NODES 中删除。
       */
      this[REF_NODES] = null;
      this[REF_BELONGS] = null;
      this[RELATED_DOM_REFS] = null;

      /**
       * If some child of this component is passed as argument(ie.
       * use arg:pass attribute) like ng-tranclude in angular 1.x,
       * the child may contain some messenger listeners not belong to
       * this component but belong to outer parent.
       *
       * When destroy this component, we should also remove messenger listeners
       *   belong to outer parent to prevent memory leak.
       * To implement this goal, we maitain VM_RELATED_LISTENERS.
       * When render view-tree, any messenger listeners belong to outer
       * parent, will be also linked under VM_RELATED_LISTENERS, then
       * when we destroy this component, the listeners can also be clear.
       *
       * For examle:
       *
       * <!-- outer parent: RootApp -->
       * <div>
       * <if expect="show">
       * <Tooltip>
       * <argument arg:pass="default">
       * <p>hello, world. my name is ${name}</p>
       * </argument>
       * </Tooltip>
       * </if>
       * </div>
       *
       * when the `show` variable changed from true to false, the
       * Tooltip component will be destroy. The messenger listener belong
       * to the outer parent RootApp which watch `name` variable should
       * also be removed.
       */
      this[VM_RELATED_LISTENERS] = null;

      // saved listener deregisters, will be auto called when component is destroied
      this[DOM_LISTENER_DEREGISTERS] = null;
      this[I18N_LISTENER_DEREGISTERS] = null;

      return wrapComponent(this);
    }

    /**
     * Helper function to add i18n LOCALE_CHANGE listener.
     * Return deregister function which will remove event listener.
     * If you do dot call deregister function, it will be auto called when component is destroied.
     * @param {Function} listener listener bind to LOCALE_CHANGE event.
     * @param {Boolean} immediate call listener immediately, useful for component property initialize
     * @returns {Function} deregister function to remove listener
     */
    [I18N_WATCH](listener, immediate) {
      const deregs = getOrCreateArrayProperty(
        this,
        I18N_LISTENER_DEREGISTERS
      );
      const unwatcher = i18n.watch(() => {
        // bind component to listener's function context.
        listener.call(this);
      }, immediate);
      const deregister = () => {
        unwatcher();
        arrayRemove(deregs, deregister);
      };
      deregs.push(deregister);
      return deregister;
    }

    /**
     * Helper function to add dom event listener.
     * Return deregister function which will remove event listener.
     * If you do dot call deregister function, it will be auto called when component is destroied.
     * @param {HtmlElement} $el
     * @param {String} eventName
     * @param {Function} listener
     * @param {Boolean|Object} capture
     * @returns {Function} deregister function to remove listener
     */
    [DOM_ON]($el, eventName, listener, capture) {
      const lisDeregister = registerEvent($el, eventName, $event => {
        // bind component to listener's function context.
        listener.call(this, $event);
      }, capture);

      const deregs = getOrCreateArrayProperty(this, DOM_LISTENER_DEREGISTERS);
      const deregister = () => {
        lisDeregister();
        arrayRemove(deregs, deregister);
      };
      deregs.push(deregister);
      return deregister;
    }

    /**
     * Helper function to pass all listener to first dom element.
     * @param {Array} ignoredEventNames event names not passed
     */
    [DOM_PASS_LISTENERS](ignoredEventNames) {
      if (this[STATE] !== STATE_RENDERED) {
        throw new Error('bindDOMListeners must be applied to component which is rendered.');
      }
      const lis = this[LISTENERS$1];
      if (!lis || lis.length === 0) {
        return;
      }
      const $el = this[GET_FIRST_DOM]();
      if ($el.nodeType !== Node.ELEMENT_NODE) {
        return;
      }
      lis.forEach((handlers, eventName) => {
        if (ignoredEventNames && ignoredEventNames.indexOf(eventName) >= 0) {
          return;
        }
        handlers.forEach(fn => {
          this[DOM_ON]($el, eventName, fn.tag ? $evt => {
            fn.tag.stop && $evt.stopPropagation();
            fn.tag.prevent && $evt.preventDefault();
            fn($evt);
          } : fn);
        });
      });
    }

    [GET_TRANSITION_DOM]() {
      const rns = this[ROOT_NODES];
      if (rns.length === 0) assertFail();
      const el = rns[0];
      return isComponent(el) ? el[GET_TRANSITION_DOM]() : el;
    }

    [GET_FIRST_DOM]() {
      const rns = this[ROOT_NODES];
      if (rns.length === 0) assertFail();
      const el = rns[0];
      return isComponent(el) ? el[GET_FIRST_DOM]() : el;
    }

    [GET_LAST_DOM]() {
      const rns = this[ROOT_NODES];
      if (rns.length === 0) assertFail();
      const el = rns[rns.length - 1];
      return isComponent(el) ? el[GET_LAST_DOM]() : el;
    }

    [CLONE]() {
      throw new Error('abstract method');
    }

    [RENDER]() {
      const Clazz = this.constructor;
      let renderFn = Clazz.template;
      if (!renderFn && this[ARG_COMPONENTS]) {
        renderFn = this[ARG_COMPONENTS][STR_DEFAULT];
      }
      if (!isFunction(renderFn)) {
        assertFail(`render function of ${Clazz.name} not found. Forget static getter "template"?`);
      }
      manager[CSTYLE_ADD](Clazz.style);
      return renderFn(this);
    }

    /**
     *
     * @param {HTMLElement} $targetDOM
     * @param {Boolean} replaceMode if false, use append mode
     */
    [RENDER_TO_DOM]($targetDOM, replaceMode = true) {
      if (!isDOMNode($targetDOM)) assertFail();
      if (this[STATE] !== STATE_INITIALIZE) {
        assertFail();
      }
      const rr = assertRenderResults(this[RENDER]());
      manager[CSTYLE_ATTACH]();
      if (replaceMode) {
        replaceChild(getParent($targetDOM), rr, $targetDOM);
      } else {
        appendChild($targetDOM, rr);
      }
      this[HANDLE_AFTER_RENDER]();
    }

    [DESTROY](removeDOM = true) {
      if (this[STATE] > STATE_WILLDESTROY) return;
      this[STATE] = STATE_WILLDESTROY;
      /*
       * once component is being destroied,
       *   we mark component and it's passed-attrs un-notifiable to ignore
       *   possible messeges occurs in BEFORE_DESTROY lifecycle callback.
       */
      this[VM_ATTRS][VM_NOTIFIABLE] = false;
      this[PASSED_ATTRS][VM_ATTRS][VM_NOTIFIABLE] = false;

      // notify before destroy lifecycle
      // 需要注意，必须先 NOTIFY 向外通知销毁消息，再执行 BEFORE_DESTROY 生命周期函数。
      //   因为在 BEFORE_DESTROY 里会销毁外部消息回调函数里可能会用到的属性等资源。
      this[NOTIFY](BEFORE_DESTROY_EVENT_NAME, this);
      this[BEFORE_DESTROY]();
      // destroy children(include child component and html nodes)
      this[HANDLE_BEFORE_DESTROY](removeDOM);
      // clear messenger listeners.
      super[CLEAR]();
      // remove component style
      manager[CSTYLE_DEL](this.constructor.style);
      // destroy attrs passed to constructor
      const attrs = this[PASSED_ATTRS];
      attrs[VM_ATTRS][VM_DESTROY]();
      // unlink all symbol property. may be unnecessary.
      getOwnPropertySymbols(attrs, p => {
        attrs[p] = null;
      });

      /*
       * reset HOST object's all public properties to null
       *   to remove HOST object from old property value's VM_PARENTS
       *
       * 将所有公共属性的属性值重置为 null，从而解除 ViewModel 之间的 VM_PARENTS 关联，回收资源和防止潜在 bug。
       *   使用 getOwnPropertyNames 可以获取所有属性，但无法获取 setter 函数定义的属性。
       *   因此，先从 VM_SETTER_FN_MAP 中取到所有使用过的属性，主动调用属性值的 REMOVE_PARENT；然后使用 getOwnPropertyNames 简单地重置 null。
       */
      const sfm = this[VM_SETTER_FN_MAP];
      if (sfm) {
        sfm.forEach((fn, prop) => {
          if (fn === null) return;
          const v = this[prop];
          if (isObject(v) && (VM_ATTRS in v)) {
            v[VM_ATTRS][VM_REMOVE_PARENT](
              this[VM_ATTRS][VM_HOST],
              prop
            );
          }
        });
        sfm.clear();
        this[VM_SETTER_FN_MAP] = null;
      }
      getOwnPropertyNames(this, prop => {
        if (isObject(this[prop])) {
          this[prop] = null;
        }
      });
      // destroy view model, it's import to pass false as argument
      this[VM_ATTRS][VM_DESTROY](false);

      // clear next tick update setImmediate
      const unm = this[UPDATE_NEXT_MAP];
      if (unm) {
        unm.forEach(imm => {
          clearImmediate(imm);
        });
        unm.clear();
        this[UPDATE_NEXT_MAP] = null;
      }

      // destroy related refs:
      destroyRelatedRefs(this);
      // clear context.
      destroyContext(this);
      // clear all dom event listener and i18n watcher
      releaseDeregisters(this, DOM_LISTENER_DEREGISTERS);
      releaseDeregisters(this, I18N_LISTENER_DEREGISTERS);

      // clear properties
      this[STATE] = STATE_DESTROIED;
      // unlink all symbol properties. maybe unnecessary.
      this[VM_SETTER_FN_MAP] =
        this[PASSED_ATTRS] =
        this[NON_ROOT_COMPONENT_NODES] =
        this[ROOT_NODES] =
        this[REF_NODES] =
        this[REF_BELONGS] =
        this[ARG_COMPONENTS] = null;
      // unlink VM_ATTRS, mark component destroied
      // 这行代码必须放在最后，因为在 ../viewmodel/proxy.js 里面，
      //   需要使用 VM_ATTRS 是否存在来判断组件是否已经销毁。
      this[VM_ATTRS] = null;
    }

    [HANDLE_BEFORE_DESTROY](removeDOM) {
      this[NON_ROOT_COMPONENT_NODES].forEach(component => {
        // it's not necessary to remove dom when destroy non-root component,
        // because those dom nodes will be auto removed when their parent dom is removed.
        component[DESTROY](false);
      });
      this[NON_ROOT_COMPONENT_NODES].length = 0;

      let $parent;
      this[ROOT_NODES].forEach(node => {
        if (isComponent(node)) {
          node[DESTROY](removeDOM);
        } else if (removeDOM) {
          if (!$parent) {
            $parent = getParent(node);
          }
          removeChild($parent, node);
        }
      });
      this[ROOT_NODES].length = 0;
    }

    [HANDLE_AFTER_RENDER]() {
      /*
       * Set NOTIFIABLE=true to enable ViewModel notify.
       * Don't forgot to add these code if you override HANDLE_AFTER_RENDER
       */
      this[PASSED_ATTRS][VM_ATTRS][VM_NOTIFIABLE] = true;
      this[VM_ATTRS][VM_NOTIFIABLE] = true;

      this[ROOT_NODES].forEach(n => {
        if (isComponent(n)) n[HANDLE_AFTER_RENDER]();
      });
      this[NON_ROOT_COMPONENT_NODES].forEach(n => {
        if (isComponent(n)) n[HANDLE_AFTER_RENDER]();
      });
      this[STATE] = STATE_RENDERED;
      this[CONTEXT_STATE] = this[CONTEXT_STATE] > 0 ? -2 : -1; // has been rendered, can't modify context
      this[AFTER_RENDER]();
      this[NOTIFY](AFTER_RENDER_EVENT_NAME, this);
    }

    /**
     *
     * @param {Function|boolean} handler
     * @param {boolean} nextTick
     */
    [UPDATE_IF_NEED](handler = null, nextTick = true) {
      if (this[STATE] !== STATE_RENDERED) {
        return;
      }
      if (handler === false) {
        return this[UPDATE]();
      }

      if (!isFunction(handler)) {
        handler = this[UPDATE];
      }

      if (!nextTick) {
        handler.call(this);
        return;
      }

      const ntMap = getOrCreateMapProperty(this, UPDATE_NEXT_MAP);
      if (ntMap.has(handler)) {
        // already in queue.
        return;
      }
      ntMap.set(handler, setImmediate(() => {
        ntMap.delete(handler);
        handler.call(this);
      }));
    }

    [UPDATE]() {
      throw new Error('abstract method');
    }

    [GET_STATE_NAME]() {
      return STATE_NAMES[this[STATE]];
    }

    [SET_CONTEXT](id, ctx, forceOverride = false) {
      if (this[CONTEXT_STATE] < 0) {
        throw new Error('Can\'t setContext after component has been rendered. Try put setContext code into constructor.');
      }
      if (this[CONTEXT_STATE] === 0) {
        // we copy context to make sure child component do not modify context passed from parent.
        // we do not copy it by default until setContext function is called, because it unnecessary to waste memory if
        // child component do not modify the context.
        if (!this[CONTEXT]) {
          this[CONTEXT] = createEmptyObject();
        } else {
          this[CONTEXT] = copyContext(this[CONTEXT]);
        }
        this[CONTEXT_STATE] = 1; // has been copied.
      }
      if (id in this[CONTEXT]) {
        // override exist may case hidden bug hard to debug.
        // so we force programmer to pass third argument to
        //   tell us he/she know what he/she is doing.
        if (!forceOverride) {
          throw new Error(`Contenxt with id: ${id.toString()} is exist. Pass third argument forceOverride=true to override it.`);
        }
      }
      this[CONTEXT][id] = ctx;
    }

    [GET_CONTEXT](id) {
      return this[CONTEXT] ? this[CONTEXT][id] : null;
    }

    [SET_REF_NODE](ref, el, relatedComponent) {
      const rns = getOrCreateMapProperty(this, REF_NODES);
      let elOrArr = rns.get(ref);
      if (!elOrArr) {
        rns.set(ref, el);
      } else if (isArray(elOrArr)) {
        elOrArr.push(el);
      } else {
        elOrArr = [elOrArr, el];
        rns.set(ref, elOrArr);
      }
      if (isComponent(el)) {
        getOrCreateArrayProperty(el, REF_BELONGS).push([
          this, ref
        ]);
        return;
      }
      if (this === relatedComponent) {
        return;
      }
      getOrCreateArrayProperty(
        relatedComponent, RELATED_DOM_REFS
      ).push([this, ref, el]);
    }

    /**
     * Get child node(or nodes) marked by 'ref:' attribute in template
     * @param {String} ref
     * @returns {Node|Array<Node>}
     */
    [GET_REF](ref) {
      if (this[STATE] !== STATE_RENDERED) {
        console.error(`Warning: call getChild before component '${this.constructor.name}' is rendered will get nothing, try put getChild into afterRender lifecycle hook.`);
      }
      return this[REF_NODES] ? this[REF_NODES].get(ref) : null;
    }

    /**
     * lifecycle hook, called after rendered.
     */
    [AFTER_RENDER]() {
      // lifecycle hook, default do nothing.
    }

    /**
     * lifecycle hook, called before destroy.
     */
    [BEFORE_DESTROY]() {
      // lifecycle hook, default do nothing.
    }
  }

  function destroyContext(comp) {
    const ctx = comp[CONTEXT];
    if (!ctx) return;
    if (comp[CONTEXT_STATE] === -2) {
      // maybe unnecessary to reset properties
      getOwnPropertyNames(ctx, propN => {
        ctx[propN] = null;
      });
      getOwnPropertySymbols(ctx, propN => {
        ctx[propN] = null;
      });
    }
    comp[CONTEXT] = null;
  }

  function releaseDeregisters(component, nameOfDeregisters) {
    if (component[nameOfDeregisters]) {
      component[nameOfDeregisters].forEach(deregister => deregister());
      component[nameOfDeregisters] = null;
    }
  }

  function destroyRelatedRefs(comp) {
    function _unref(refBelongs, el) {
      if (!refBelongs) return;
      refBelongs.forEach(info => {
        const map = info[0][REF_NODES];
        if (!map) return;
        const rns = map.get(info[1]);
        if (isArray(rns)) {
          arrayRemove(rns, el || info[2]);
        } else {
          map.delete(info[1]);
        }
      });
    }
    _unref(comp[REF_BELONGS], comp);
    _unref(comp[RELATED_DOM_REFS]);
  }

  function isComponent(c) {
    return ROOT_NODES in c;
  }

  function assertRenderResults(renderResults) {
    if (!isArray(renderResults) || renderResults.length === 0) {
      throw new Error('Render results of component is empty');
    }
    return renderResults;
  }

  function operateRootHtmlDOM(fn, el, ...args) {
    if (!isComponent(el)) return fn(el, ...args);
    el[ROOT_NODES].forEach(ce => {
      operateRootHtmlDOM(fn, ce, ...args);
    });
  }

  function bootstrap(Component, dom, attrs) {
    if (dom === document.body) {
      throw new Error('bootstrap dom cannot be document.body');
    }
    /**
     * as we must pass ViewModel-Object as first argument to Component constructor,
     * we simple pass an empty attrs.
     */
    const bootAttrs = attrs || {};
    const bootComponent = new Component(wrapAttrs(bootAttrs));
    if (!isComponent(bootComponent)) assertFail();
    bootComponent[RENDER_TO_DOM](dom);
  }

  function emptyRenderFn(component) {
    const el = createComment(STR_EMPTY);
    component[ROOT_NODES].push(el);
    return [el];
  }

  function errorRenderFn(component) {
    const el = createElement('span', {
      style: 'color: red !important;'
    });
    el.textContent = 'template parsing failed! please check webpack log.';
    component[ROOT_NODES].push(el);
    return [el];
  }

  function textRenderFn(component, txtContent) {
    const el = createTextNode(txtContent);
    component[ROOT_NODES].push(el);
    return el;
  }

  function i18nRenderFn(component, key) {
    const el = createTextNode();
    const fn = () => {
      el.textContent = i18n[I18N_GET_TEXT](key);
    };
    fn();
    component[I18N_WATCH](fn);
    component[ROOT_NODES].push(el);
    return el;
  }

  const TS_TRANSITION_END = 'transitionend';
  const TS_ANIMATION_END = 'animationend';
  const TS_TRANSITION_DURATION = 'transition-duration';
  const TS_ANIMATION_DURATION = 'animation-duration';
  const TS_TRANSITION = 'transition';
  const TS_ZERO_S = '0s';
  const TS_ENTER = 'enter';
  const TS_LEAVE = 'leave';
  const TS_C_ENTER = '-enter';
  const TS_C_LEAVE = '-leave';
  const TS_C_ENTER_ACTIVE = '-enter-active';
  const TS_C_LEAVE_ACTIVE = '-leave-active';
  const TS_BEFORE_ENTER = 'before-enter';
  const TS_AFTER_ENTER = 'after-enter';
  const TS_BEFORE_LEAVE = 'before-leave';
  const TS_AFTER_LEAVE = 'after-leave';
  const TS_ENTER_CANCELLED = 'enter-cancelled';
  const TS_LEAVE_CANCELLED = 'leave-cancelled';

  const TS_STATE_ENTERING = 1;
  const TS_STATE_ENTERED = 2;
  const TS_STATE_LEAVING = 3;
  const TS_STATE_LEAVED = 4;

  function getDurationType(el) {
    const cst = getComputedStyle$1(el);
    if (getCSPropertyValue(cst, TS_TRANSITION_DURATION) !== TS_ZERO_S) {
      return TS_TRANSITION_END;
    } else if (getCSPropertyValue(cst, TS_ANIMATION_DURATION) !== TS_ZERO_S) {
      return TS_ANIMATION_END;
    }
    return null;
  }

  function parseDuration(v) {
    if (/ms$/.test(v)) {
      return parseInt(v);
    } else if (/s$/.test(v)) {
      return parseFloat(v) * 1000;
    } else {
      return 0;
    }
  }

  function getDuration(el) {
    const cst = getComputedStyle$1(el);
    let dur = getCSPropertyValue(cst, TS_TRANSITION_DURATION);
    if (dur !== TS_ZERO_S) {
      return [TS_TRANSITION_END, parseDuration(dur)];
    }
    dur = getCSPropertyValue(cst, TS_ANIMATION_DURATION);
    if (dur !== TS_ZERO_S) {
      return [TS_ANIMATION_END, parseDuration(dur)];
    }
    return [null, 0];
  }

  class ToggleClassComponent extends Component {
    constructor(attrs) {
      if (!attrs || !isObject(attrs.class)) {
        throw new Error('<toggle-class> component require "class" attribute to be Object.');
      }
      const vm_ea2ee6919f = super(attrs);
      const fn_ea2ee6919f_2 = () => {
        vm_ea2ee6919f.class = attrs.class;
      };
      fn_ea2ee6919f_2();
      attrs[VM_ATTRS][VM_ON]('class', fn_ea2ee6919f_2);
      const fn_ea2ee6919f_3 = () => {
        vm_ea2ee6919f.trans = !!attrs.transition;
      };
      fn_ea2ee6919f_3();
      attrs[VM_ATTRS][VM_ON]('transition', fn_ea2ee6919f_3);
      vm_ea2ee6919f._t = null;
      vm_ea2ee6919f._i = null;
      vmWatch(this, 'class.**', () => {
        vm_ea2ee6919f[UPDATE_IF_NEED]();
      });
      return vm_ea2ee6919f;
    }

    [RENDER]() {
      const rr = super[RENDER]();
      this[UPDATE](true);
      return rr;
    }

    [BEFORE_DESTROY]() {
      this._t && this._t.clear();
    }

    [UPDATE](init) {
      const el = this.trans ? this[GET_TRANSITION_DOM]() : this;
      if (el.nodeType !== Node.ELEMENT_NODE) {
        // ignore comment or text-node
        return;
      }
      if (this.trans && !this._t) {
        this._t = new Map();
      }
      const cs = this.class;
      Object.keys(cs).forEach(k => {
        const v = cs[k];
        if (!this.trans) {
          operateRootHtmlDOM(
            v ? addClass : removeClass,
            el, k
          );
          return;
        }

        if (init) {
          this._t.set(k, [
            v ? TS_STATE_ENTERED : TS_STATE_LEAVED, // state
            null // saved onEnd callback
          ]);
          v ? addClass(el, k) : removeClass(el, k);
          return;
        }

        const t = this._t.get(k);
        if (!t) {
          console.error('Unsupport <toogle-class> attribute. see https://todo');
          return;
        }
        const s = t[0];
        if ((v && s <= TS_STATE_ENTERED) || (!v && s >= TS_STATE_LEAVING)) {
          return;
        }

        if (s === (v ? TS_STATE_LEAVING : TS_STATE_ENTERING)) {
          // debugger;
          removeClass(el, k + (v ? TS_C_LEAVE : TS_C_ENTER));
          removeClass(el, k + (v ? TS_C_LEAVE_ACTIVE : TS_C_ENTER_ACTIVE));
          removeEvent(el, TS_TRANSITION_END, t[1]);
          removeEvent(el, TS_ANIMATION_END, t[1]);
          t[1] = null;
          this[NOTIFY](TS_TRANSITION, v ? TS_LEAVE_CANCELLED : TS_ENTER_CANCELLED, k, el);
        }
        const classOfStart = k + (v ? TS_C_ENTER : TS_C_LEAVE);
        const classOfActive = k + (v ? TS_C_ENTER_ACTIVE : TS_C_LEAVE_ACTIVE);
        addClass(el, classOfStart);
        // force render by calling getComputedStyle
        getDurationType(el);
        addClass(el, classOfActive);
        const tsEndName = getDurationType(el);
        if (!tsEndName) {
          removeClass(el, classOfStart);
          removeClass(el, classOfActive);
          t[0] = v ? TS_STATE_ENTERED : TS_STATE_LEAVED;
          v ? addClass(el, k) : removeClass(el, k);
          return;
        }
        const onEnd = () => {
          removeEvent(el, TS_TRANSITION_END, onEnd);
          removeEvent(el, TS_ANIMATION_END, onEnd);
          removeClass(el, classOfStart);
          removeClass(el, classOfActive);
          t[1] = null;
          t[0] = v ? TS_STATE_ENTERED : TS_STATE_LEAVED;
          v ? addClass(el, k) : removeClass(el, k);
          this[NOTIFY](TS_TRANSITION, v ? TS_AFTER_ENTER : TS_AFTER_LEAVE, k, el);
        };
        t[0] = v ? TS_STATE_ENTERING : TS_STATE_LEAVING;
        t[1] = onEnd;
        addEvent(el, tsEndName, onEnd);
        this[NOTIFY](TS_TRANSITION, v ? TS_BEFORE_ENTER : TS_BEFORE_LEAVE, k, el);
        setImmediate(() => {
          this[NOTIFY](TS_TRANSITION, v ? TS_ENTER : TS_LEAVE, k, el);
        });
      });
    }
  }

  const FOR_LENGTH = Symbol$1('length');
  const FOR_KEYS = Symbol$1('keys');
  const FOR_KEY_NAME = Symbol$1('key');
  const FOR_WAIT_UPDATE = Symbol$1('waiting_update');
  const FOR_UPDATE_ITEM = Symbol$1('update_item');

  const KEY_INDEX = 'index';
  const KEY_EACH = 'each';
  const EMP_ARR = [];

  class ForEachComponent extends Component {
    constructor(attrs, item, index, isLast) {
      const vm_ea2ee6919f = super(attrs);
      vm_ea2ee6919f.each = item;
      vm_ea2ee6919f.index = index;
      vm_ea2ee6919f.isFirst = index === 0;
      vm_ea2ee6919f.isLast = isLast;
      return vm_ea2ee6919f;
    }

    [RENDER]() {
      const renderFn = this[ARG_COMPONENTS][STR_DEFAULT];
      if (!renderFn) assertFail();
      return renderFn(this);
    }
  }

  function createEl(item, i, isLast, itemRenderFn, context, cstyPid) {
    const el = new ForEachComponent(wrapAttrs({
      [VM_DEBUG_NAME]: 'attrs_of_<for-each>',
      [VM_ATTRS]: null,
      [CONTEXT]: context,
      [ARG_COMPONENTS]: {
        [STR_DEFAULT]: itemRenderFn
      }
    }), item, i, isLast);
    cstyPid && addParentStyleId(el, cstyPid);
    return el;
  }

  function appendRenderEach(item, i, isLast, itemRenderFn, roots, context, cstyPid) {
    const el = createEl(item, i, isLast, itemRenderFn, context, cstyPid);
    roots.push(el);
    return el[RENDER]();
  }

  function _assertVm(item, i) {
    if (isObject(item) && !isInnerObj(item) && !(VM_ATTRS in item)) {
      throw new Error(`loop item [${i}] of <for> component must be ViewModel.`);
    }
  }

  function _prepareKey(item, i, keyMap, keyName) {
    const key = keyName === KEY_EACH ? item : keyName(item);
    if (keyMap.has(key)) {
      console.error(`loop items [${i}] and [${keyMap.get(key)}] of <for> component both have key '${key}', dulplicated key may cause update error.`);
    }
    keyMap.set(key, i);
    return key;
  }

  function renderItems(items, itemRenderFn, roots, keys, keyName, context, cstyPid) {
    const result = [];
    const tmpKeyMap = new Map();
    items.forEach((item, i) => {
      _assertVm(item, i);
      if (keyName !== KEY_INDEX) {
        keys.push(_prepareKey(item, i, tmpKeyMap, keyName));
      }
      result.push(...appendRenderEach(item, i, i === items.length - 1, itemRenderFn, roots, context, cstyPid));
    });
    return result;
  }

  function loopAppend($parent, el) {
    el[ROOT_NODES].forEach(node => {
      if (isComponent(node)) {
        loopAppend($parent, node);
      } else {
        appendChild($parent, node);
      }
    });
  }

  function updateEl(el, i, items) {
    if (el.isFirst !== (i === 0)) {
      el.isFirst = i === 0;
    }
    if (el.isLast !== (i === items.length - 1)) {
      el.isLast = (i === items.length - 1);
    }
    if (el.index !== i) {
      el.index = i;
    }
    if (el.each !== items[i]) {
      el.each = items[i];
    }
  }

  function _parseIndexPath(p) {
    return (isString(p) && p !== STR_LENGTH && /^\d+$/.test(p)) ? Number(p) : p;
  }

  let INC = 0;
  const ID = Symbol$1('id');

  class ForComponent extends Component {
    constructor(attrs) {
      if (attrs.key && !/^(index|each(.[\w\d$_]+)*)$/.test(attrs.key)) {
        throw new Error('Value of "_key" attribute of <for> component is invalidate. See https://[todo]');
      }
      const vm_ea2ee6919f = super(attrs);
      const fn_ea2ee6919f_2 = () => {
        vm_ea2ee6919f.loop = attrs.loop;
      };
      fn_ea2ee6919f_2();
      attrs[VM_ATTRS][VM_ON]('loop', fn_ea2ee6919f_2);
      vm_ea2ee6919f[ID] = INC++;
      const kn = attrs.key || KEY_INDEX;
      vm_ea2ee6919f[FOR_KEY_NAME] = kn;
      vm_ea2ee6919f[FOR_LENGTH] = 0;
      vm_ea2ee6919f[FOR_KEYS] = null;
      vm_ea2ee6919f[FOR_WAIT_UPDATE] = false;
      if (kn !== KEY_INDEX && kn !== KEY_EACH) {
        vm_ea2ee6919f[FOR_KEY_NAME] = new Function(KEY_EACH, `return ${ kn }`);
        const propCount = kn.split('.').length + 1;
        vmWatch(this, 'loop.*.' + kn.slice(5), propPath => {
          if (propPath.length !== propCount || vm_ea2ee6919f[FOR_WAIT_UPDATE]) {
            return;
          }
          const items = vm_ea2ee6919f.loop;
          if (!isArray(items) || items.length === 0)
            return;
          const p = _parseIndexPath(propPath[1]);
          if (!isNumber(p) || p >= items.length) {
            return;
          }
          vm_ea2ee6919f[FOR_KEYS][p] = vm_ea2ee6919f[FOR_KEY_NAME](items[p]);
        });
      }
      vmWatch(this, 'loop.*', propPath => {
        if (vm_ea2ee6919f[STATE] !== STATE_RENDERED || propPath.length !== 2 || vm_ea2ee6919f[FOR_WAIT_UPDATE]) {
          return;
        }
        const p = _parseIndexPath(propPath[1]);
        if (p === STR_LENGTH) {
          vm_ea2ee6919f[FOR_WAIT_UPDATE] = true;
          vm_ea2ee6919f[UPDATE_IF_NEED]();
        } else if (isNumber(p)) {
          vm_ea2ee6919f[FOR_UPDATE_ITEM](p);
        }
      });
      return vm_ea2ee6919f;
    }

    get loop() {
      return this._l;
    }

    set loop(v) {
      // console.log('set loop');
      this._l = v;
      this[FOR_WAIT_UPDATE] = true;
      this[UPDATE_IF_NEED]();
    }

    [RENDER]() {
      const roots = this[ROOT_NODES];
      const itemRenderFn = this[ARG_COMPONENTS] ? this[ARG_COMPONENTS][STR_DEFAULT] : null;
      if (!itemRenderFn) {
        roots.push(createComment(STR_EMPTY));
        return roots;
      }
      const items = this.loop;
      const keyName = this[FOR_KEY_NAME];
      if (keyName !== KEY_INDEX) this[FOR_KEYS] = [];
      if (!isArray(items) || items.length === 0) {
        roots.push(createComment(STR_EMPTY));
        return roots;
      }
      this[FOR_LENGTH] = items.length;
      return renderItems(
        items,
        itemRenderFn,
        roots,
        this[FOR_KEYS],
        keyName,
        this[CONTEXT],
        this[CSTYLE_PID]
      );
    }

    [FOR_UPDATE_ITEM](index) {
      const items = this.loop;
      const roots = this[ROOT_NODES];
      if (!isArray(items) || index >= roots.length) return;
      const keys = this[FOR_KEYS];
      const item = items[index];
      const oldEl = roots[index];
      if (oldEl.each === item) {
        return;
      }
      const itemRenderFn = this[ARG_COMPONENTS] ? this[ARG_COMPONENTS][STR_DEFAULT] : null;
      if (!itemRenderFn) return;
      // console.log('update item:', index);
      const keyName = this[FOR_KEY_NAME];
      if (keyName !== KEY_INDEX) {
        const newKey = keyName === KEY_EACH ? item : keyName(item);
        const oldKey = keys[index];
        if (newKey !== oldKey) {
          const $fd = oldEl[GET_FIRST_DOM]();
          const newEl = createEl(
            item, index, oldEl.isLast,
            itemRenderFn, this[CONTEXT], this[CSTYLE_PID]
          );
          const rr = newEl[RENDER]();
          insertBefore(getParent($fd), rr, $fd);
          oldEl[DESTROY]();
          roots[index] = newEl;
          keys[index] = newKey;
          newEl[HANDLE_AFTER_RENDER]();
          // console.log('update item render:', index);
        } else {
          oldEl.each = item;
        }
      } else {
        oldEl.each = item;
      }
    }

    [UPDATE]() {
      this[FOR_WAIT_UPDATE] = false;
      // console.log('for update');
      const itemRenderFn = this[ARG_COMPONENTS] ? this[ARG_COMPONENTS][STR_DEFAULT] : null;
      if (!itemRenderFn) return;

      const newItems = isArray(this.loop) ? this.loop : EMP_ARR;
      const roots = this[ROOT_NODES];
      const nl = newItems.length;
      const ol = this[FOR_LENGTH];
      // nothing changed, return directly.
      if (nl === 0 && ol === 0) return;

      const keyName = this[FOR_KEY_NAME];
      // if new length equal 0, clear & render comment.
      if (nl === 0 && ol > 0) {
        const fd = roots[0][GET_FIRST_DOM]();
        const $cmt = createComment(STR_EMPTY);
        insertBefore(getParent(fd), $cmt, fd);
        for (let i = 0; i < ol; i++) {
          roots[i][DESTROY]();
        }
        roots.length = 1;
        roots[0] = $cmt;
        if (keyName !== KEY_INDEX) {
          this[FOR_KEYS].length = 0;
        }
        this[FOR_LENGTH] = 0;
        return;
      }

      this[FOR_LENGTH] = nl;
      const ctx = this[CONTEXT];
      const cstyPid = this[CSTYLE_PID];
      const firstEl = roots[0]; // if ol === 0, firstEl is comment, else is component
      const $parent = getParent(ol === 0 ? firstEl : firstEl[GET_FIRST_DOM]());

      if (keyName === KEY_INDEX) {
        let $f = null;
        if (ol === 0) roots.length = 0;

        for (let i = 0; i < nl; i++) {
          if (i < ol) {
            updateEl(roots[i], i, newItems);
          } else {
            if (!$f) $f = createFragment();
            appendChild($f, ...appendRenderEach(newItems[i], i, i === nl - 1, itemRenderFn, roots, ctx, cstyPid));
          }
        }
        if ($f) {
          const $le = ol === 0 ? firstEl : roots[ol - 1][GET_LAST_DOM]();
          insertAfter($parent, $f, $le);
          for (let i = ol; i < nl; i++) {
            roots[i][HANDLE_AFTER_RENDER]();
          }
        }
        if (ol === 0) {
          removeChild($parent, firstEl);
        }
        if (nl >= ol) return;
        for (let i = nl; i < ol; i++) {
          roots[i][DESTROY]();
        }
        roots.splice(nl);

        return;
      }

      const oldKeys = this[FOR_KEYS];
      if (ol === 0) {
        roots.length = 0;
        const rs = renderItems(
          newItems, itemRenderFn, roots,
          oldKeys, keyName, this[CONTEXT], this[CSTYLE_PID]
        );
        insertAfter($parent, createFragment(rs), firstEl);
        removeChild($parent, firstEl);
        roots.forEach(el => el[HANDLE_AFTER_RENDER]());
        return;
      }

      const oldKeyMap = new Map();
      oldKeys.forEach((k, i) => {
        oldKeyMap.set(k, i);
      });
      const newKeys = [];
      const newKeyMap = new Map();
      newItems.forEach((item, i) => {
        _assertVm(item, i);
        newKeys.push(_prepareKey(item, i, newKeyMap, keyName));
      });

      let oi = 0;
      let ni = 0;
      let $lastS = null;
      const newRoots = [];
      const oldTags = new Uint8Array(ol);
      while (oi < ol || ni < nl) {
        while (oi < ol) {
          if (oldTags[oi] !== 0) {
            oi++;
          } else if (newKeyMap.has(oldKeys[oi]) && newKeyMap.get(oldKeys[oi]) >= ni) {
            if (oi === ol - 1) {
              $lastS = roots[oi][GET_LAST_DOM]().nextSibling;
            }
            break;
          } else {
            if (oi === ol - 1) {
              $lastS = roots[oi][GET_LAST_DOM]().nextSibling;
            }
            roots[oi][DESTROY]();
            oi++;
          }
        }
        if (oi >= ol) {
          let $f = null;
          const cei = newRoots.length;
          for (; ni < nl; ni++) {
            const el = createEl(newItems[ni], ni, ni === nl - 1, itemRenderFn, ctx, cstyPid);
            if (!$f) $f = createFragment();
            appendChild($f, ...el[RENDER]());
            newRoots.push(el);
          }
          if ($f) {
            if ($lastS) {
              insertBefore($parent, $f, $lastS);
            } else {
              appendChild($parent, $f);
            }
            for (let i = cei; i < newRoots.length; i++) {
              newRoots[i][HANDLE_AFTER_RENDER]();
            }
          }
          break;
        }
        const oldKey = oldKeys[oi];
        let $f = null;
        let $nes = null;
        while (ni < nl) {
          const newKey = newKeys[ni];
          if (newKey === oldKey) break;

          let reuseEl = null;
          if (oldKeyMap.has(newKey)) {
            const oldIdx = oldKeyMap.get(newKey);
            if (oldIdx > oi && oldTags[oldIdx] === 0) {
              reuseEl = roots[oldIdx];
              oldTags[oldIdx] = 1;
            }
          }
          if (!$f) $f = createFragment();
          if (!reuseEl) {
            reuseEl = createEl(newItems[ni], ni, ni === nl - 1, itemRenderFn, ctx, cstyPid);
            appendChild($f, ...reuseEl[RENDER]());
            if (!$nes) $nes = [];
            $nes.push(reuseEl);
          } else {
            loopAppend($f, reuseEl);
            updateEl(reuseEl, ni, newItems);
          }
          newRoots.push(reuseEl);
          ni++;
        }
        if (ni >= nl) {
          assertFail('unimpossible?!');
        }
        const el = roots[oi];
        $f && insertBefore($parent, $f, el[GET_FIRST_DOM]());
        $nes && $nes.forEach(el => el[HANDLE_AFTER_RENDER]());
        updateEl(el, ni, newItems);
        newRoots.push(el);
        oi++;
        ni++;
      }

      this[ROOT_NODES] = newRoots;
      this[FOR_KEYS] = newKeys;
    }
  }

  const STR_JG_HIDE = 'jg-hide';

  class HideComponent extends ToggleClassComponent {
    constructor(attrs) {
      attrs.class = wrapViewModel({
        [STR_JG_HIDE]: !!attrs.test
      });
      vmWatch(attrs, 'test', () => {
        if (attrs.class[STR_JG_HIDE] !== attrs.test) {
          attrs.class[STR_JG_HIDE] = attrs.test;
        }
      });
      // eslint-disable-next-line constructor-super
      return super(attrs);
    }
  }

  function renderHtml(content) {
    const $d = createElementWithoutAttrs('div');
    $d.innerHTML = content || '';
    let cn = $d.childNodes;
    if (cn.length === 0) {
      cn = [createComment(STR_EMPTY)];
    } else {
      cn = [].slice.call(cn); // convert NodeList to Array.
    }
    return cn;
  }

  class BindHtmlComponent extends Component {
    constructor(attrs) {
      if (attrs[ARG_COMPONENTS])
        throw new Error('<bind-html/> don\'t accept any child.');
      if (!('content' in attrs))
        throw new Error('<bind-html/> require "content" attribute');
      const vm_ea2ee6919f = super(attrs);
      const fn_ea2ee6919f_3 = () => {
        vm_ea2ee6919f.c = attrs.content;
      };
      fn_ea2ee6919f_3();
      attrs[VM_ATTRS][VM_ON]('content', fn_ea2ee6919f_3);
      return vm_ea2ee6919f;
    }

    get c() {
      return this._c;
    }

    set c(v) {
      if (this._c === v) return;
      this._c = v;
      this[UPDATE_IF_NEED]();
    }

    [RENDER]() {
      return (this[ROOT_NODES] = renderHtml(this._c));
    }

    [UPDATE]() {
      const roots = this[ROOT_NODES];
      const oldFirstEl = roots[0];
      const $p = getParent(oldFirstEl);
      const newEls = renderHtml(this._c);
      insertBefore($p, newEls, oldFirstEl);
      roots.forEach(oldEl => removeChild($p, oldEl));
      this[ROOT_NODES] = newEls;
    }
  }

  const IF_STR_ELSE = 'else';
  const T_MAP = Symbol$1('transition_map');
  const P_VAL = Symbol$1('previous_value');
  const OE_H = Symbol$1('on_end_handler');

  const C_BV = Symbol$1('current_branch_value');
  const C_VAL = Symbol$1('current_value');
  const ON_TS_END = Symbol$1('on_ts_end');

  function createEl$1(renderFn, context, parentStyleIds) {
    const el = new Component(wrapAttrs({
      [VM_DEBUG_NAME]: 'attrs_of_<if>',
      [VM_ATTRS]: null,
      [CONTEXT]: context,
      [ARG_COMPONENTS]: {
        [STR_DEFAULT]: renderFn
      }
    }));
    parentStyleIds && addParentStyleId(el, parentStyleIds);
    return el;
  }

  function renderSwitch(component) {
    const value = component[C_VAL];
    const acs = component[ARG_COMPONENTS];
    if (component.ts && acs) {
      const t = new Map();
      for (const k in acs) {
        t.set(k, [
          k === value ? TS_STATE_ENTERED : TS_STATE_LEAVED,
          null // element
        ]);
      }
      component[T_MAP] = t;
      component[P_VAL] = value;
      component[OE_H] = component[ON_TS_END].bind(component);
    }
    const renderFn = acs ? acs[value] : null;
    const roots = component[ROOT_NODES];
    if (!renderFn) {
      roots.push(createComment(STR_EMPTY));
      return roots;
    }
    const el = createEl$1(renderFn, component[CONTEXT], component[CSTYLE_PID]);
    roots.push(el);
    return el[RENDER]();
  }

  function updateSwitch(component) {
    if (!isComponent(component[ROOT_NODES][0]) && (
      !component[ARG_COMPONENTS] || !component[ARG_COMPONENTS][component[C_VAL]]
    )) {
      return;
    }

    if (component[T_MAP]) {
      return updateSwitchWithTransition(component);
    }

    doUpdate(component);
  }

  function doUpdate(component) {
    const roots = component[ROOT_NODES];
    const el = roots[0];
    const isC = isComponent(el);
    const fd = isC ? el[GET_FIRST_DOM]() : el;
    const pa = getParent(isC ? fd : el);
    const renderFn = component[ARG_COMPONENTS] ? component[ARG_COMPONENTS][component[C_VAL]] : null;
    const ne = renderFn ? createEl$1(renderFn, component[CONTEXT], component[CSTYLE_PID]) : null;
    roots[0] = ne || createComment(STR_EMPTY);
    insertBefore(
      pa,
      ne ? ne[RENDER]() : roots[0],
      fd
    );
    if (isC) {
      el[DESTROY]();
    } else {
      removeChild(pa, fd);
    }
    ne && renderFn && ne[HANDLE_AFTER_RENDER]();
    component[NOTIFY]('branch-switched', component[C_BV]);
  }

  function cancelTs(t, tn, e, component) {
    const el = t[1];
    if (el.nodeType !== Node.ELEMENT_NODE) {
      return;
    }
    const onEnd = component[OE_H];
    removeClass(el, tn + (e ? TS_C_ENTER : TS_C_LEAVE));
    removeClass(el, tn + (e ? TS_C_ENTER_ACTIVE : TS_C_LEAVE_ACTIVE));
    removeEvent(el, TS_TRANSITION_END, onEnd);
    removeEvent(el, TS_ANIMATION_END, onEnd);
    component[NOTIFY](TS_TRANSITION, e ? TS_ENTER_CANCELLED : TS_LEAVE_CANCELLED, el);
  }

  function startTs(t, tn, e, component) {
    const el = t[1];
    const onEnd = component[OE_H];
    if (el.nodeType !== Node.ELEMENT_NODE) {
      onEnd();
      return;
    }
    const classOfStart = tn + (e ? TS_C_ENTER : TS_C_LEAVE);
    const classOfActive = tn + (e ? TS_C_ENTER_ACTIVE : TS_C_LEAVE_ACTIVE);

    addClass(el, classOfStart);
    // force render by calling getComputedStyle
    getDurationType(el);
    addClass(el, classOfActive);
    const tsEndName = getDurationType(el);
    if (!tsEndName) {
      onEnd();
      return;
    }
    t[0] = e ? TS_STATE_ENTERING : TS_STATE_LEAVING;
    addEvent(el, tsEndName, onEnd);
    component[NOTIFY](TS_TRANSITION, e ? TS_BEFORE_ENTER : TS_BEFORE_LEAVE, el);
    setImmediate(() => {
      component[NOTIFY](TS_TRANSITION, e ? TS_ENTER : TS_LEAVE, el);
    });
  }
  function updateSwitchWithTransition(component) {
    const value = component[C_VAL];
    const pv = component[P_VAL];
    const tn = component.ts;
    let pt = component[T_MAP].get(pv);
    if (!pt) {
      pt = [
        pv === IF_STR_ELSE ? TS_STATE_LEAVED : TS_STATE_ENTERED,
        null // element
      ];
      component[T_MAP].set(pv, pt);
    }
    // debugger;
    if (pt[0] === TS_STATE_ENTERING) {
      if (value === pv) return;
      cancelTs(pt, tn, true, component);
      startTs(pt, tn, false, component);
    } else if (pt[0] === TS_STATE_LEAVING) {
      if (value !== pv) return;
      cancelTs(pt, tn, false, component);
      startTs(pt, tn, true, component);
    } else if (pt[0] === TS_STATE_ENTERED) {
      pt[1] = component[GET_TRANSITION_DOM]();
      startTs(pt, tn, false, component);
    } else if (pt[0] === TS_STATE_LEAVED) {
      pt[1] = component[GET_TRANSITION_DOM]();
      startTs(pt, tn, true, component);
    }
  }

  function updateSwitchOnTransitionEnd(component) {
    // console.log('on end')
    const value = component[C_VAL];
    const pv = component[P_VAL];
    const tn = component.ts;
    const pt = component[T_MAP].get(pv);
    const e = pt[0] === TS_STATE_ENTERING;
    const el = pt[1];

    if (el.nodeType === Node.ELEMENT_NODE) {
      removeEvent(el, TS_TRANSITION_END, component[OE_H]);
      removeEvent(el, TS_ANIMATION_END, component[OE_H]);
      removeClass(el, tn + (e ? TS_C_ENTER : TS_C_LEAVE));
      removeClass(el, tn + (e ? TS_C_ENTER_ACTIVE : TS_C_LEAVE_ACTIVE));
      component[NOTIFY](TS_TRANSITION, e ? TS_AFTER_ENTER : TS_AFTER_LEAVE);
    }

    pt[0] = e ? TS_STATE_ENTERED : TS_STATE_LEAVED;

    if (e) return;

    doUpdate(component);
    component[P_VAL] = value;
    const ct = component[T_MAP].get(value);
    if (!ct) {
      return;
    }
    const fd = component[GET_TRANSITION_DOM]();
    if (fd.nodeType !== Node.ELEMENT_NODE) {
      ct[0] = TS_STATE_ENTERED;
      return;
    }

    ct[1] = fd;
    startTs(ct, tn, true, component);
  }

  function destroySwitch(component) {
    const tMap = component[T_MAP];
    if (tMap) {
      tMap.forEach((ts, v) => {
        if (ts[1]) {
          removeEvent(ts[1], TS_TRANSITION_END, component[OE_H]);
          removeEvent(ts[1], TS_ANIMATION_END, component[OE_H]);
        }
        ts.length = 0;
      });
      tMap.clear();
    }
  }

  class IfComponent extends Component {
    constructor(attrs) {
      const vm_ea2ee6919f = super(attrs);
      vm_ea2ee6919f[C_VAL] = STR_DEFAULT;
      vm_ea2ee6919f[OE_H] = null;
      vm_ea2ee6919f[T_MAP] = null;
      vm_ea2ee6919f[P_VAL] = null;
      const fn_ea2ee6919f_5 = () => {
        vm_ea2ee6919f.expect = attrs.expect;
      };
      fn_ea2ee6919f_5();
      attrs[VM_ATTRS][VM_ON]('expect', fn_ea2ee6919f_5);
      const fn_ea2ee6919f_6 = () => {
        vm_ea2ee6919f.ts = attrs.transition;
      };
      fn_ea2ee6919f_6();
      attrs[VM_ATTRS][VM_ON]('transition', fn_ea2ee6919f_6);
      return vm_ea2ee6919f;
    }

    get expect() {
      return this[C_VAL] === STR_DEFAULT;
    }

    set expect(v) {
      v = v ? STR_DEFAULT : IF_STR_ELSE;
      if (this[C_VAL] === v) return;
      this[C_VAL] = v;
      this[UPDATE_IF_NEED]();
    }

    get [C_BV]() {
      return this.expect;
    }

    [ON_TS_END]() {
      updateSwitchOnTransitionEnd(this);
    }

    [RENDER]() {
      return renderSwitch(this);
    }

    [UPDATE]() {
      updateSwitch(this);
    }

    [BEFORE_DESTROY]() {
      destroySwitch(this);
    }
  }

  class SwitchComponent extends Component {
    constructor(attrs) {
      const vm_ea2ee6919f = super(attrs);
      vm_ea2ee6919f[OE_H] = null;
      vm_ea2ee6919f[T_MAP] = null;
      vm_ea2ee6919f[P_VAL] = null;
      const fn_ea2ee6919f_4 = () => {
        vm_ea2ee6919f.test = attrs.test;
      };
      fn_ea2ee6919f_4();
      attrs[VM_ATTRS][VM_ON]('test', fn_ea2ee6919f_4);
      const fn_ea2ee6919f_5 = () => {
        vm_ea2ee6919f.ts = attrs.transition;
      };
      fn_ea2ee6919f_5();
      attrs[VM_ATTRS][VM_ON]('transition', fn_ea2ee6919f_5);
      return vm_ea2ee6919f;
    }

    get test() {
      return this[C_VAL];
    }

    set test(v) {
      const acs = this[ARG_COMPONENTS];
      if (!acs || !(v in acs)) {
        v = STR_DEFAULT;
      }
      if (this[C_VAL] === v) return;
      this[C_VAL] = v;
      this[UPDATE_IF_NEED]();
    }

    get [C_BV]() {
      return this.test;
    }

    [ON_TS_END]() {
      updateSwitchOnTransitionEnd(this);
    }

    [RENDER]() {
      return renderSwitch(this);
    }

    [UPDATE]() {
      updateSwitch(this);
    }

    [BEFORE_DESTROY]() {
      destroySwitch(this);
    }
  }

  class ParameterComponent extends Component {
    constructor(attrs, params) {
      const vm_ea2ee6919f = super(attrs);
      params.forEach(p => {
        vm_ea2ee6919f[p] = attrs[p];
        attrs[VM_ATTRS][VM_ON](p, () => {
          vm_ea2ee6919f[p] = attrs[p];
        });
      });
      return vm_ea2ee6919f;
    }
  }

  /**
   * This component is only for development purpose
   */
  class LogComponent extends Component {
    constructor(attrs) {
      const vm_ea2ee6919f = super(attrs);
      const fn_ea2ee6919f_1 = () => {
        vm_ea2ee6919f.msg = attrs.msg;
      };
      fn_ea2ee6919f_1();
      attrs[VM_ATTRS][VM_ON]('msg', fn_ea2ee6919f_1);
      return vm_ea2ee6919f;
    }

    set msg(v) {
      console.log(v);
      this._msg = v;
    }

    get msg() {
      return this._msg;
    }

    [RENDER]() {
      return [createComment('log placeholder')];
    }
  }

  const RENDER_KEY = Symbol('render_key');
  const RENDER_VMS = Symbol('render_vms');
  const ON_LOCALE_CHANGE = Symbol('fn_on_locale_change');

  class I18nComponent extends Component {
    constructor(attrs, renderKey, renderVms) {
      const vm_ea2ee6919f = super(attrs);
      vm_ea2ee6919f[RENDER_KEY] = renderKey;
      vm_ea2ee6919f[RENDER_VMS] = renderVms;
      vm_ea2ee6919f[I18N_WATCH](vm_ea2ee6919f[ON_LOCALE_CHANGE]);
      return vm_ea2ee6919f;
    }

    [RENDER]() {
      const renderFn = i18n[I18N_GET_RENDER](this[RENDER_KEY]);
      return renderFn(this, ...this[RENDER_VMS]);
    }

    [ON_LOCALE_CHANGE]() {
      this[UPDATE_IF_NEED]();
    }

    [UPDATE]() {
      vmRelatedClear(this[VM_RELATED_LISTENERS]);

      let $el = this[GET_LAST_DOM]();
      const $parentEl = getParent($el);
      $el = $el.nextSibling;

      /*
       * 当前实现下，HANDLE_BEFORE_DESTROY 正好可以销毁子组件/子元素。
       */
      this[HANDLE_BEFORE_DESTROY](true);
      /*
       * 将新的元素替换到原来的旧的元素的位置。
       */
      const els = this[RENDER]();
      if ($el) {
        insertBefore($parentEl, els, $el);
      } else {
        appendChild($parentEl, els);
      }
    }

    [BEFORE_DESTROY]() {
      this[RENDER_VMS] = null; // unlink vms, maybe not necessary
    }
  }

  exports.AFTER_RENDER = AFTER_RENDER;
  exports.AFTER_RENDER_EVENT_NAME = AFTER_RENDER_EVENT_NAME;
  exports.ARG_COMPONENTS = ARG_COMPONENTS;
  exports.ArrayProxyHandler = ArrayProxyHandler;
  exports.BEFORE_DESTROY = BEFORE_DESTROY;
  exports.BEFORE_DESTROY_EVENT_NAME = BEFORE_DESTROY_EVENT_NAME;
  exports.BindHtmlComponent = BindHtmlComponent;
  exports.CLEAR = CLEAR;
  exports.CLONE = CLONE;
  exports.CONTEXT = CONTEXT;
  exports.CONTEXT_STATE = CONTEXT_STATE;
  exports.CSTYLE_ADD = CSTYLE_ADD;
  exports.CSTYLE_ATTACH = CSTYLE_ATTACH;
  exports.CSTYLE_DEL = CSTYLE_DEL;
  exports.CSTYLE_PID = CSTYLE_PID;
  exports.Component = Component;
  exports.ComponentProxyHandler = ComponentProxyHandler;
  exports.DESTROY = DESTROY;
  exports.DOM_ON = DOM_ON;
  exports.DOM_PASS_LISTENERS = DOM_PASS_LISTENERS;
  exports.FOR_KEYS = FOR_KEYS;
  exports.FOR_KEY_NAME = FOR_KEY_NAME;
  exports.FOR_LENGTH = FOR_LENGTH;
  exports.FOR_UPDATE_ITEM = FOR_UPDATE_ITEM;
  exports.FOR_WAIT_UPDATE = FOR_WAIT_UPDATE;
  exports.ForComponent = ForComponent;
  exports.ForEachComponent = ForEachComponent;
  exports.GET_CONTEXT = GET_CONTEXT;
  exports.GET_FIRST_DOM = GET_FIRST_DOM;
  exports.GET_LAST_DOM = GET_LAST_DOM;
  exports.GET_REF = GET_REF;
  exports.GET_STATE_NAME = GET_STATE_NAME;
  exports.GET_TRANSITION_DOM = GET_TRANSITION_DOM;
  exports.HANDLE_AFTER_RENDER = HANDLE_AFTER_RENDER;
  exports.HANDLE_BEFORE_DESTROY = HANDLE_BEFORE_DESTROY;
  exports.HTML_ATTR_autocomplete = HTML_ATTR_autocomplete;
  exports.HTML_ATTR_autofocus = HTML_ATTR_autofocus;
  exports.HTML_ATTR_autoplay = HTML_ATTR_autoplay;
  exports.HTML_ATTR_checked = HTML_ATTR_checked;
  exports.HTML_ATTR_controls = HTML_ATTR_controls;
  exports.HTML_ATTR_disabled = HTML_ATTR_disabled;
  exports.HTML_ATTR_draggable = HTML_ATTR_draggable;
  exports.HTML_ATTR_multiple = HTML_ATTR_multiple;
  exports.HTML_ATTR_muted = HTML_ATTR_muted;
  exports.HTML_ATTR_readOnly = HTML_ATTR_readOnly;
  exports.HTML_ATTR_required = HTML_ATTR_required;
  exports.HTML_ATTR_selected = HTML_ATTR_selected;
  exports.HTML_ATTR_value = HTML_ATTR_value;
  exports.HideComponent = HideComponent;
  exports.I18N_CURRENT_LOCALE = I18N_CURRENT_LOCALE;
  exports.I18N_GET_ATTR = I18N_GET_ATTR;
  exports.I18N_GET_RENDER = I18N_GET_RENDER;
  exports.I18N_GET_TEXT = I18N_GET_TEXT;
  exports.I18N_LOCALE_CHANGE = I18N_LOCALE_CHANGE;
  exports.I18N_RENDER_DEPS = I18N_RENDER_DEPS;
  exports.I18N_SWITCH_LOCALE = I18N_SWITCH_LOCALE;
  exports.I18N_WATCH = I18N_WATCH;
  exports.I18nComponent = I18nComponent;
  exports.IfComponent = IfComponent;
  exports.LISTENERS = LISTENERS$1;
  exports.LogComponent = LogComponent;
  exports.Messenger = Messenger;
  exports.NON_ROOT_COMPONENT_NODES = NON_ROOT_COMPONENT_NODES;
  exports.NOTIFY = NOTIFY;
  exports.NOTIFY_TRANSITION = NOTIFY_TRANSITION;
  exports.OFF = OFF;
  exports.ON = ON;
  exports.ObjectProxyHandler = ObjectProxyHandler;
  exports.PASSED_ATTRS = PASSED_ATTRS;
  exports.ParameterComponent = ParameterComponent;
  exports.PromiseProxyHandler = PromiseProxyHandler;
  exports.REF_BELONGS = REF_BELONGS;
  exports.REF_NODES = REF_NODES;
  exports.RELATED_DOM_REFS = RELATED_DOM_REFS;
  exports.RENDER = RENDER;
  exports.RENDER_TO_DOM = RENDER_TO_DOM;
  exports.ROOT_NODES = ROOT_NODES;
  exports.RelatedListenersStore = RelatedListenersStore;
  exports.SET_CONTEXT = SET_CONTEXT;
  exports.SET_REF_NODE = SET_REF_NODE;
  exports.STATE = STATE;
  exports.STATE_DESTROIED = STATE_DESTROIED;
  exports.STATE_INITIALIZE = STATE_INITIALIZE;
  exports.STATE_NAMES = STATE_NAMES;
  exports.STATE_RENDERED = STATE_RENDERED;
  exports.STATE_WILLDESTROY = STATE_WILLDESTROY;
  exports.STR_DEFAULT = STR_DEFAULT;
  exports.STR_EMPTY = STR_EMPTY;
  exports.STR_JG_HIDE = STR_JG_HIDE;
  exports.STR_JINGE = STR_JINGE;
  exports.STR_LENGTH = STR_LENGTH;
  exports.SwitchComponent = SwitchComponent;
  exports.Symbol = Symbol$1;
  exports.TEMPLATE_RENDER = TEMPLATE_RENDER;
  exports.TS_AFTER_ENTER = TS_AFTER_ENTER;
  exports.TS_AFTER_LEAVE = TS_AFTER_LEAVE;
  exports.TS_ANIMATION_DURATION = TS_ANIMATION_DURATION;
  exports.TS_ANIMATION_END = TS_ANIMATION_END;
  exports.TS_BEFORE_ENTER = TS_BEFORE_ENTER;
  exports.TS_BEFORE_LEAVE = TS_BEFORE_LEAVE;
  exports.TS_C_ENTER = TS_C_ENTER;
  exports.TS_C_ENTER_ACTIVE = TS_C_ENTER_ACTIVE;
  exports.TS_C_LEAVE = TS_C_LEAVE;
  exports.TS_C_LEAVE_ACTIVE = TS_C_LEAVE_ACTIVE;
  exports.TS_ENTER = TS_ENTER;
  exports.TS_ENTER_CANCELLED = TS_ENTER_CANCELLED;
  exports.TS_LEAVE = TS_LEAVE;
  exports.TS_LEAVE_CANCELLED = TS_LEAVE_CANCELLED;
  exports.TS_STATE_ENTERED = TS_STATE_ENTERED;
  exports.TS_STATE_ENTERING = TS_STATE_ENTERING;
  exports.TS_STATE_LEAVED = TS_STATE_LEAVED;
  exports.TS_STATE_LEAVING = TS_STATE_LEAVING;
  exports.TS_TRANSITION = TS_TRANSITION;
  exports.TS_TRANSITION_DURATION = TS_TRANSITION_DURATION;
  exports.TS_TRANSITION_END = TS_TRANSITION_END;
  exports.TS_ZERO_S = TS_ZERO_S;
  exports.ToggleClassComponent = ToggleClassComponent;
  exports.UPDATE = UPDATE;
  exports.UPDATE_IF_NEED = UPDATE_IF_NEED;
  exports.UPDATE_NEXT_MAP = UPDATE_NEXT_MAP;
  exports.VM = VM;
  exports.VM_ADD_PARENT = VM_ADD_PARENT;
  exports.VM_ATTRS = VM_ATTRS;
  exports.VM_DEBUG_NAME = VM_DEBUG_NAME;
  exports.VM_DESTROY = VM_DESTROY;
  exports.VM_HOST = VM_HOST;
  exports.VM_NOTIFIABLE = VM_NOTIFIABLE;
  exports.VM_NOTIFY = VM_NOTIFY;
  exports.VM_OFF = VM_OFF;
  exports.VM_ON = VM_ON;
  exports.VM_PROXY = VM_PROXY;
  exports.VM_RELATED_LISTENERS = VM_RELATED_LISTENERS;
  exports.VM_REMOVE_PARENT = VM_REMOVE_PARENT;
  exports.VM_SETTER_FN_MAP = VM_SETTER_FN_MAP;
  exports.VM_SHIFT_PARENT = VM_SHIFT_PARENT;
  exports.ViewModelAttrs = ViewModelAttrs;
  exports._t = _t;
  exports.addClass = addClass;
  exports.addEvent = addEvent;
  exports.addParentStyleId = addParentStyleId;
  exports.appendChild = appendChild;
  exports.arrayEqual = arrayEqual;
  exports.arrayFind = arrayFind;
  exports.arrayFindIndex = arrayFindIndex;
  exports.arrayIndexOf = arrayIndexOf;
  exports.arrayPushIfNotExist = arrayPushIfNotExist;
  exports.arrayRemove = arrayRemove;
  exports.assertFail = assertFail;
  exports.assertRenderResults = assertRenderResults;
  exports.assignObject = assignObject;
  exports.bootstrap = bootstrap;
  exports.clearHelper = clearHelper;
  exports.clearImmediate = clearImmediate;
  exports.createComment = createComment;
  exports.createElement = createElement;
  exports.createElementWithChild = createElementWithChild;
  exports.createElementWithoutAttrs = createElementWithoutAttrs;
  exports.createEmptyObject = createEmptyObject;
  exports.createFragment = createFragment;
  exports.createSVGElement = createSVGElement;
  exports.createSVGElementWithoutAttrs = createSVGElementWithoutAttrs;
  exports.createTextNode = createTextNode;
  exports.defineProperties = defineProperties;
  exports.defineProperty = defineProperty;
  exports.destroyRelatedRefs = destroyRelatedRefs;
  exports.emptyRenderFn = emptyRenderFn;
  exports.endsWith = endsWith;
  exports.errorRenderFn = errorRenderFn;
  exports.getCSPropertyValue = getCSPropertyValue;
  exports.getComputedStyle = getComputedStyle$1;
  exports.getDuration = getDuration;
  exports.getDurationType = getDurationType;
  exports.getOrCreateArrayProperty = getOrCreateArrayProperty;
  exports.getOrCreateArrayValueOfMap = getOrCreateArrayValueOfMap;
  exports.getOrCreateMapProperty = getOrCreateMapProperty;
  exports.getOrCreateProperty = getOrCreateProperty;
  exports.getOrCreateValueOfMap = getOrCreateValueOfMap;
  exports.getOwnPropertyNames = getOwnPropertyNames;
  exports.getOwnPropertySymbols = getOwnPropertySymbols;
  exports.getParent = getParent;
  exports.hasClass = hasClass;
  exports.i18n = i18n;
  exports.i18nRenderFn = i18nRenderFn;
  exports.insertAfter = insertAfter;
  exports.insertBefore = insertBefore;
  exports.instanceOf = instanceOf;
  exports.isArray = isArray;
  exports.isBoolean = isBoolean;
  exports.isComponent = isComponent;
  exports.isDOMNode = isDOMNode;
  exports.isFunction = isFunction;
  exports.isInnerObj = isInnerObj;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isPromise = isPromise;
  exports.isPropertyEnumerable = isPropertyEnumerable;
  exports.isPublicProp = isPublicProp;
  exports.isString = isString;
  exports.isUndefined = isUndefined;
  exports.isViewModel = isViewModel;
  exports.manager = manager;
  exports.mapObject = mapObject;
  exports.notifyHelper = notifyHelper;
  exports.obj2class = obj2class;
  exports.obj2style = obj2style;
  exports.offHelper = offHelper;
  exports.onHelper = onHelper;
  exports.onceHelper = onceHelper;
  exports.operateRootHtmlDOM = operateRootHtmlDOM;
  exports.passListeners = passListeners;
  exports.registerEvent = registerEvent;
  exports.removeAttribute = removeAttribute;
  exports.removeChild = removeChild;
  exports.removeClass = removeClass;
  exports.removeEvent = removeEvent;
  exports.replaceChild = replaceChild;
  exports.replaceClass = replaceClass;
  exports.setAttribute = setAttribute;
  exports.setImmediate = setImmediate;
  exports.setInputValue = setInputValue;
  exports.setText = setText;
  exports.startsWith = startsWith;
  exports.textRenderFn = textRenderFn;
  exports.toggleClass = toggleClass;
  exports.typeOf = typeOf;
  exports.uid = uid;
  exports.vmRelatedClear = vmRelatedClear;
  exports.vmUnwatch = vmUnwatch;
  exports.vmWatch = vmWatch;
  exports.wrapAttrs = wrapAttrs;
  exports.wrapComponent = wrapComponent;
  exports.wrapViewModel = wrapViewModel;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
