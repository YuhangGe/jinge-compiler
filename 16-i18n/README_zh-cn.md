# 国际化多语言（i18n）

中文 | [English](./)

## 概述

目前的很多 mvvm 框架对国际化多语言的支持都是基于第三方实现，加载多语言字典（key-text）文件后，通过 key 来查找 text。这些方案往往需要在代码里定义 key，当项目模块很多的情况下，需要通过约定 key 的规则或其它方法来避免冲突。同时，模板代码看起来不够简洁。

jinge 在框架层面引入了对国际化多语言的支持，使得多语言的实现更加简洁和高效。当然，如果框架内置的多语言功能不能很好契合实际的业务需求，仍然可以像其它框架那样实现一套第三方多语言方案，且并不复杂。

jinge 框架内置的多语言功能，具体来讲，是引入了多语言辅助组件`<_t>`，多语言辅助属性 `_t:`，以及多语言辅助函数 `_t()`。

`<_t>` 辅助组件用于在模板中包裹需要翻译的文本串，`_t:` 用于在模板中指定需要翻译的属性值。比如：

````html
<p><_t>你好，世界！</_t></p>
<p><_t>你好，${name}！</_t></p>
<for e:loop="boys" vm:each="boy">
  <p>你好，${boy.name}，我是你们的老师${name}。</p>
  <Boy _t:name="一年级一班的${boy.name}"/>
</for>
<p>
  <_t>
    中文下面<span style="color:red">这里是红色的</span>
  <_t>
</p>
````

可以看出来，`<_t>` 对模板代码的入侵性非常小，一个不支持多语言的项目改造成需要支持多语言的项目，只需要简单地用 `<_t>` 来包裹。

`_t()` 函数用于在 js 代码中包裹需要翻译的文本串，例如：

````js
import {
  _t
} from 'jinge';

console.log(_t('你好，世界'));
````

在内核层面，jinge 框架的多语言，最终也是（key-text）的字典查找方案。只不过，编译器(webpack loader)会自动将这些文本串提取，生成多语言的字典(key-text)文件，并将源码中文本串对应替换成 key。通过这种方式，使得编码的时候无需感知罗嗦的 key，也不需要关注大型前端项目中跨模块的 key 的冲突问题。同时，生成的字典也会自动避免完全相同的文本串的大量重复，从而减小大型前端项目的多语言字典包的体积。

## 研发流程

以下流程描述为简要介绍，详细代码以及参数的字段含义，参看此 demo 的源码。

1. webpack 中引入 JingeWebpackPlugin，并配置 i18n 相关参数，其中，defaultLocale 为必须参数，假设配置为 `zh_cn`。
2. 在源码中使用 `<_t>` 组件，`_t:` 类型的属性，或 `_t()` 函数包裹需要翻译的文本串。
3. `npm run dev` 或 `npm run build` 后，会在 `translate` 目录（可配置）生成 `translate.zh_cn.csv`，文件内容包括两列，第二列是文本串，第一列是文本串所在的源码文件（用于定位文本串的上下文，以辅助翻译）。
4. 翻译 `translate.zh_cn.csv` ，每一个目标语言，对应一个格式为 `translate.[targetLocale].csv` 的文件，文件内容包括三列，前两列和 `translate.zh_cn.csv` 完全一致，第三列是翻译后的文本串。
5. 重新运行 `npm run dev` 或 `npm run build` 后，会在 `dist` 目录（可配置）生成文件名格式为 `locale.[targetLocale].js` （可配置）的文件。

在第 5 步运行时，也仍然会执行第 3 步的生成（覆盖） `translate.zh_cn.csv` 的动作；并且会更新（覆盖）每一个 `translate.[targetLocale].csv` 文件，将其中已经被删除的文本串也删除，将新出现的未翻译的文本串添加到文件顶部。所以本质上第 5 步和第 3 步是同一个步骤。

需要注意的是，第 3 步生成 csv 以及字典文件，都只在 webpack 第一次生成 bundle 时执行，不会监控 csv 文件的变化。源码发生变化后，发生变化的那个文件，会退回不使用多语言的代码，也就是 `<_t>`、`_t:` 和 `_t()` 都会被忽略。这样做的原因是实际研发中，并不会有频繁地多语言切换调试，基本都是默认语言下把某个模块开发好了，然后统一翻译，再测试翻译后结果。

## 加载字典

第一种方式是，在 `index.html` 文件中，在加载 bundle 之前，先加载需要的默认语言的字典文件。比如这个 demo 的 index.html 使用的方法。这种方式适合 `index.html` 可以由后端动态渲染的场景，比如后端根据登录用户的会话信息拿到用户配置的默认语言，渲染到 `index.html` 里去。

第二种方式是，在 `index.html` 中只加载一个辅助的 `loader.js` 文件，这个文件里，先通过 api 接口读取登录用户的信息，拿到配置的语言，然后把字典文件和 bundle 文件用 `<script async="false">` 的形式添加到 index.html。如果不想使用 `<script>` 而是想直接先 `fetch` 代码然后 `eval` 执行脚本，则只要先执行字典文件，再执行 bundle 既可。

## 切换语言

第一种方式是，直接刷新页面。整个页面会重新执行加载字典逻辑，从而取到用户最近配置的语言选项。这种方式简单粗暴，优点是 js 代码里不需要考虑热更新的处理（详见下文），缺点是页面会重载，体验不够顺滑。

第二种方式是，使用 `i18n.switch(locale, filename)` 热切换语言。 第一个必选参数是目标语言。第二个可选参数是语言字典文件名模板，当 webpack.config.js 里的 i18n 的参数不是默认参数的情况下，比如使用了自定义的路径或文件名，则此处也要同时指定完整的文件名。比如，webpack.config.js 里有如下配置：

````js
// webpack.config.js
{
  output: {
    path: 'dist'
  },
  plugins: [ new JingeWebpackPlugin({
    i18n: {
      output: {
        // 默认为 locale.[locale].js
        filename: 'locale/[locale].js'
      }
    }
  })]
}
````

实际生成的字典文件会位于 `dist` 目录下的 `locale` 子目录。对应的浏览器端的热切换代码为：

````js
import {
  i18n
} from 'jinge';

i18n.switch('en', '/dist/locale/[locale].js');
````

## 文本串热切换

在模板里的 `<_t>` 和 `_t:` 可以自动实现当 `i18n.switch` 调用时热切换文本串。但 js 源码里的 `_t()` 无法自动热切换，需要手动处理。

可以使用 `i18n.watch(listener, immediate = false)` 函数监控语言是否发生了变化。第一个必须参数是监听回调函数，第二个可选参数是是否立即执行一次该回调函数。这个 watch 函数的返回值也是一个函数，用于销毁之前的监听。

如果是在组件（Component）里面处理热切换，可以使用一个便捷的监听函数，`this[I18N_WATCH](listener, immediate)`，函数参数和 `i18n.watch` 一致，返回值也是一个用于取消监听的函数。但这个组件的成员函数可以在组件被销毁时，自动销毁所有监听，从而即避免内存泄漏，又不需要业务层去手动处理销毁。还有一个小区别是，`this[I18N_WATCH]` 在触发 listener 时，会自动将 listener 的函数上下文设置成这个组件，即使用 `listener.apply(this, arguments)` 的形式调用回调。

需要注意的是，当文本串出现在文件的顶部时，无法实现热切换。比如，某个服务会对外输出常量字符串，传统的写法往往如下：

````js
export SOME_CONST_VAR = '你好，世界！';
````

改成多语言后的简单写法是：

````js
import { _t } from 'jinge';
export SOME_CONST_VAR = _t('你好，世界！');
````

这种写法无法实现热切换，因为无法修改 js 引擎里某个变量的内存地址对应的数据。如果是采用这种写法，切换语言时就只能采取重新加载整个 app 的方案。

想要实现等价的功能，即将常量字符串暴露给外部，又可以热切换，只能采取在具体的业务需求下，结合 ViewModel 的消息机制和 i18n 服务的监听来具体地处理。比如一个可能的方案是：

````js
import { _t, VM } from 'jinge';
export SOME_CONST_VARS = VM({});
i18n.watch(() => {
  Object.assign(SOME_CONST_VARS, {
    varA: _t('你好，世界！');
  });
}, true);
````

通过这种方式，业务层可以直接使用 SOME_CONST_VARS 的 ViewModel 消息机制获知文本串的变更。 业务层还可以使用 `i18n.watch` 来处理，但这个方案并不靠谱，因为需要注意 i18n.watch 注册的先后顺序，如果业务层先注册，则会在服务层变更文本串之前就执行了监听回调（从而拿不到变更后的文本串）。