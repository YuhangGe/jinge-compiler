# Watching ViewModel

中文 | [English](./)

jinge 框架提供了对 ViewModel 的直接监控能力。但需要`特别注意`的是，在 jinge 框架中，`watch` 是基于`赋值路径`而不是基于`值变化`的，这一点和其它主流框架都不一样。

jinge 框架建议不要直接对 ViewModel 进行 watch， 因为 watch 会导致代码的逻辑不够清晰和可控（特别是使用 deep watch），也不利于代码的可迁移性（在多个前端框架间迁移或迁移为服务端渲染）。事实上，通过良好的设计，任何需要 watch 来实现的功能，都可以用更简单地非 watch 模式实现。angular 在版本 2 之后不再提供 1.x 版本时的 $watch 功能便是一个例子。此外，由于 jinge 框架的 watch 机制跟其它框架的 watch 机制都不一样，直接对 ViewModel 进行 watch 的代码更无法迁移，且容易让不熟悉 jinge 框架的开发者误解代码。

如果一定要直接对 ViewModel 使用 watch 来追求更快捷地实现功能，则务必理解`基于赋值路径的 watch`和`基于值变化的 watch`的区别。

### 基于值变化的 watch

这是其它主流框架的模式，但**不是** jinge 框架的模式。这种模式下，框架内部会暂存每个被 watch 的表达式的值，在表达式的值可能发生变化的时候，对该表达式的新值和暂存的旧值对比，当新旧值不一样时，则通知对该表达式的监听。

这种模式的优势是简洁易懂，缺点是存储旧值要占用额外的一倍内存。

### 基于赋值路径的 watch

这是 jinge 框架的 watch 模式。当 ViewModel 出现`赋值`行为时，该赋值行为（或者说赋值代码）一定对应了某个`属性路径`。

比如，`this.a = 10`，属性路径是 `a`；`this.b.c[3].e = {}`，属性路径是 `b.c.3.e`。属性路径是动态运行时层面的，并非静态代码层面。比如：

````js
const obj = {
  list: [{
    name: 'p'
  }]
};
const idx = 0;
const tmp = obj.list;
tmp[idx]['n' + 'ame'] = 'p';
````

上述代码的最后一行赋值语句执行行，该赋值行为，相对于 `obj` 这个对像而言，其`属性路径`是 `list.0.name`；相对于 `tmp` 这个对像而言，是 `0.name`。

该赋值语句，会`通知（notify）`在 `obj` 上对 `list.0.name` 的监听以及 `tmp` 上对 `0.name` 的监听，即使该赋值语句前后的值没有变化（都是 'p'）。

同时，对监听的通知，会`同时通知到该属性路径的子路径`。比如上述的例子里，如果执行这行代码：`obj.list = [{name: 'p2'}]`，则会通知在 `obj` 上对 `list` 的监听，同时会通知在 `obj` 上对 `list.0` 和 `list.0.name` 的监听，因为这后两者都是前者的子路径。

需要注意的是，即使是执行 `obj.list = []` 也会通知在 `obj` 上对 `list.0.name` 的监听，即便 `list[0].name` 是没有意义的（因为 list 是空数组）。这个例子也进一步说明了`基于赋值路径`的通知机制的特殊性，它只关注赋值行为的属性路径，不关心具体的值（包括值是什么，是否发生变化，是否存在，等等）。

#### deep watch

`基于赋值路径的 watch` 的 `deep watch` 是直接在属性路径字符串层面引入了通配符。具体来讲，引入了 `*` 和 `**` 两类通配符，且含义跟主流的 path glob 的通配符一致。

`*` 代表当前这一层的通配。比如，在 `obj` 上：监听 `*` 代表对所有一级子路径进行监听（比如 obj.a, obj.b，但不包括 obj.a.c）；监听 `list.*` 代表对属性路径 `list` 的所有一级子路径进行监听（但不包括该 `list` 路径`）。

`**` 代表通配父亲的所有子节点（及子节点的递归子节点）。比如，在 `obj` 上：监听 `**` 则代表对所有属性路径及递归子路径进行监听；监听 `list.**` 则代表对属性路径 `list` 及其所有子属性路径进行监听（即包括该 `list` 路径本身）。


#### 通配置符的特别例子

`基于赋值路径`的监听机制，在使用通配符时，可能产生一些难于理解的例子。

比如本示例中的源码中，`test3()` 函数里执行了 `this.boy1.children.push({name:'ppp'})`，由于 push 函数会改变数组，jinge 框架会认为这也是一个对 `children` 对像的赋值行为。该赋值行为的属性路径，相对于 boy1 是 "children"。在 `boy1` 上，有对 `*.name` 的监听；而 "children" 这个路径，匹配到了 `*` 这个通配路径，因此会通知 `*` 这个路径上的监听，同时通知其子路径的监听。由于 `*.name` 是 `*` 的子路径，因此也会被通知。

为了更好理解这个例子，假设 `test3()` 函数里执行的是 `this.boy1.children = {name: 'xx'}`，这个代码把 children 对像从 array 变成了 object。从赋值行为角度看，这个代码和前文的调用 push 函数的代码是完全等价的，都是在对 children 进行赋值行为，赋值行为的属性路径都是 'children'。这个情况下，'children' 路径通知 boy1 上对 `*.name` 的监听是有意义的，因为这个监听的值从 `undefined` 变成了 `"xx"`。 
