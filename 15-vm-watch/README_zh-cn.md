# Watching ViewModel

中文 | [English](./)

jinge 框架提供了对 ViewModel 的基于`赋值路径`数据监听(`watch`)能力，包括 `vmWatch` 和 `vmUnwatch` 两个函数。

通常情况下，不建议使用数据监听函数，而是尽量用包括使用 `getter/setter` 在内的方式去处理对数据变更的处理。
因为 `vmWatch` 函数会导致代码的逻辑不够清晰和可控，也不利于代码的可迁移性（在多个前端mvvm框架间迁移或迁移为服务端渲染）。
只有当使用其它方式都会导致代码特别繁琐（比如需要手写十个以上重复模式的 getter/setter 等）的情况时，才直接使用 `vmWatch` 函数来避免代码过于罗嗦。

当 ViewModel 出现`赋值`行为时，该赋值行为（或者说赋值代码）一定对应了某个`属性路径`：

比如，`this.a = 10`，属性路径是 `a`；`this.b.c[3].e = {}`，属性路径是 `b.c.3.e`。属性路径是动态运行时层面的，并非静态代码层面。比如：

````js
const obj = {
  list: [{
    name: 'p'
  }]
};
const idx = 0;
const tmp = obj.list;
tmp[idx]['n' + 'ame'] = 'p2';
````

上述代码的最后一行赋值语句执行时，该赋值行为，相对于 `obj` 这个对像而言，其`属性路径`是 `list.0.name`；相对于 `tmp` 这个对像而言，是 `0.name`。

该赋值语句，会`通知（notify）`在 `obj` 上对 `list.0.name` 的监听以及 `tmp` 上对 `0.name` 的监听。

同时，对监听的通知，会`同时通知到该属性路径的子路径`。比如上述的例子里，如果执行这行代码：`obj.list = [{name: 'p2'}]`，则会通知在 `obj` 上对 `list` 的监听，同时会通知在 `obj` 上对 `list.0` 和 `list.0.name` 的监听，因为这后两者都是前者的子路径。

需要注意的是，即使是执行 `obj.list = []` 也会通知在 `obj` 上对 `list.0.name` 的监听，即便 `list[0].name` 是没有意义的（list 是空数组）。

正因为`基于赋值路径`的通知机制的只关注 js 语言中的赋值语句以及赋值行为对应的属性路径，不关心属性对应的值（比如上文提到的 list\[0].name 这个值没有意义），所以跟其它框架的数据监听方案不同的是，`vmWatch` 接收的回调函数被调用时，不传递新旧值做为回调参数。

#### 深度监控(Deep Watch)

跟其它框架有所区别的是，对数据的深度监控，不是靠给 `vmWatch` 传递 `deepWatch=true` 这样的参数，而是直接在属性路径字符串层面引入了通配符。具体来讲，引入了 `*` 和 `**` 两类通配符，且含义跟主流的 path glob 的通配符一致。

`*` 代表当前这一层的通配。比如，在 `obj` 上：监听 `*` 代表对所有一级子路径进行监听（比如 obj.a, obj.b，但不包括 obj.a.c）；监听 `list.*` 代表对属性路径 `list` 的所有一级子路径进行监听（但不包括该 `list` 路径`）。

`**` 代表通配父亲的所有子节点（及子节点的递归子节点）。比如，在 `obj` 上：监听 `**` 则代表对所有属性路径及递归子路径进行监听；监听 `list.**` 则代表对属性路径 `list` 及其所有子属性路径进行监听（即包括该 `list` 路径本身）。

#### 触发监听回调函数的条件

基于`赋值路径`数据监听，会在 js 代码的赋值语句出现时，触发框架的响应逻辑。在框架的响应逻辑里，会对比赋值前后的值的关系，如果前后的值不同（使用 === 判断，不考虑 Object 的内部是否变化），或者前后的值相同但都是 undefined，都会触发对数据的监听回调函数（也就是 vmWatch 的第二个参数）。
